# Stats

| [Github License](https://github.com/deadratfink/jy-transform/blob/master/LICENSE.md) | [Github Issues](https://github.com/deadratfink/jy-transform/issues) | [Github Release](https://github.com/deadratfink/jy-transform/releases) | [Github Tags](https://github.com/deadratfink/jy-transform/tags) | [Travis CI](https://travis-ci.org) | [Waffle](https://waffle.io/deadratfink/jy-transform) | [Code Climate](https://codeclimate.com/github/deadratfink/jy-transform) |
| --- | --- | --- | --- | --- | --- | --- |
| [![License][gh-license-image]][gh-license-url] | [![Issue Stats][gh-issues-image]][gh-issues-url] | [![Github Releases][gh-releases-image]][gh-releases-url] | [![Github Tags][gh-tags-image]][gh-tags-url] | [![Build Status][ci-image]][ci-url] | [![Waffle][waffle-image]][waffle-url] | [![Code Climate][cocl-image]][cocl-url] |

| Branch | [Codecov](https://codecov.io) | [Coveralls](https://coveralls.io) | [Inch CI](http://inch-ci.org) | [David](https://david-dm.org) DM | [David](https://david-dm.org) DM (dev) |
| --- | --- | --- | --- | --- | --- |
| master | [![codecov.io][cc-image-master]][cc-url-master]           | [![coveralls.io][ca-image-master]][ca-url-master]           | [![inch-ci.org][inch-image-master]][inch-url-master]           | [![Dependency Status][dep-image-master]][dep-url-master]           | [![devDependency Status][devdep-image-master]][devdep-url-master] |
| development | [![codecov.io][cc-image-development]][cc-url-development] | [![coveralls.io][ca-image-development]][ca-url-development] | [![inch-ci.org][inch-image-development]][inch-url-development] | [![Dependency Status][dep-image-development]][dep-url-development] | [![devDependency Status][devdep-image-development]][devdep-url-development] |

## Coverage Graphs

| Branch | Graph |
| --- | --- |
| master | ![codecov.io](https://codecov.io/github/deadratfink/jy-transform/branch.svg?branch=master&vg=true) |
| development| ![codecov.io](https://codecov.io/github/deadratfink/jy-transform/branch.svg?branch=development&vg=true) |


[gh-license-image]: https://img.shields.io/github/license/deadratfink/jy-transform.svg?style=flat-square
[gh-license-url]: https://github.com/deadratfink/jy-transform/blob/master/LICENSE.md

[gh-issues-image]: https://img.shields.io/github/issues/deadratfink/jy-transform.svg?style=flat-square
[gh-issues-url]: https://github.com/deadratfink/jy-transform/issues

[gh-releases-image]: https://img.shields.io/github/release/deadratfink/jy-transform.svg?style=flat-square
[gh-releases-url]: https://github.com/deadratfink/jy-transform/releases

[gh-tags-image]: https://img.shields.io/github/tag/deadratfink/jy-transform.svg?style=flat-square
[gh-tags-url]: https://github.com/deadratfink/jy-transform/tags


[ci-image]: https://img.shields.io/travis/deadratfink/jy-transform.svg?style=flat-square
[ci-url]: https://travis-ci.org/deadratfink/jy-transform/branches

[is-pull-image]: http://issuestats.com/github/deadratfink/jy-transform/badge/pr?style=flat-square
[is-issue-image]: http://issuestats.com/github/deadratfink/jy-transform/badge/issue?style=flat-square
[is-url]: http://issuestats.com/github/deadratfink/jy-transform

[waffle-image]: https://badge.waffle.io/deadratfink/jy-transform.png?label=ready&title=Ready&style=flat-square
[waffle-url]: https://waffle.io/deadratfink/jy-transform

[cocl-image]: https://img.shields.io/codeclimate/github/deadratfink/jy-transform.svg?style=flat-square
[cocl-url]: https://codeclimate.com/github/deadratfink/jy-transform


[cc-image-master]: https://img.shields.io/codecov/c/github/deadratfink/jy-transform/master.svg?style=flat-square
[cc-url-master]: https://codecov.io/github/deadratfink/jy-transform?branch=master
[cc-image-development]: https://img.shields.io/codecov/c/github/deadratfink/jy-transform/development.svg?style=flat-square
[cc-url-development]: https://codecov.io/github/deadratfink/jy-transform?branch=development

[ca-image-master]: https://img.shields.io/coveralls/deadratfink/jy-transform/master.svg?style=flat-square
[ca-url-master]: https://coveralls.io/github/deadratfink/jy-transform?branch=master
[ca-image-development]: https://img.shields.io/coveralls/deadratfink/jy-transform/development.svg?style=flat-square
[ca-url-development]: https://coveralls.io/github/deadratfink/jy-transform?branch=development


[inch-image-master]: https://inch-ci.org/github/deadratfink/jy-transform.svg?branch=master&style=flat-square
[inch-url-master]: https://inch-ci.org/github/deadratfink/jy-transform?branch=master
[inch-image-development]: https://inch-ci.org/github/deadratfink/jy-transform.svg?branch=development&style=flat-square
[inch-url-development]: https://inch-ci.org/github/deadratfink/jy-transform?branch=development

[dep-image-master]: https://img.shields.io/david/deadratfink/jy-transform/master.svg?style=flat-square
[dep-url-master]: https://david-dm.org/deadratfink/jy-transform/master
[dep-image-development]: https://img.shields.io/david/deadratfink/jy-transform/development.svg?style=flat-square
[dep-url-development]: https://david-dm.org/deadratfink/jy-transform/development

[devdep-image-master]: https://img.shields.io/david/dev/deadratfink/jy-transform/master.svg?style=flat-square
[devdep-url-master]: https://david-dm.org/deadratfink/jy-transform/master#info=devDependencies
[devdep-image-development]: https://img.shields.io/david/dev/deadratfink/jy-transform/development.svg?style=flat-square
[devdep-url-development]: https://david-dm.org/deadratfink/jy-transform/development#info=devDependencies

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
# TOC

- [jy-transform](#jy-transform)
  - [Installation](#installation)
  - [Tests](#tests)
  - [Dependencies](#dependencies)
  - [Dev Dependencies](#dev-dependencies)
  - [License](#license)
  - [Motivation](#motivation)
  - [Contributing](#contributing)
- [Usage](#usage)
  - [Usage Types](#usage-types)
  - [Use Cases](#use-cases)
  - [Limitations](#limitations)
  - [CLI Usage](#cli-usage)
  - [Origin and Target Type Inference](#origin-and-target-type-inference)
  - [API Usage](#api-usage)
  - [Using Custom Logger](#using-custom-logger)
- [API Reference](#api-reference)
  - [Classes](#classes)
  - [Typedefs](#typedefs)
  - [Constants](#constants)
  - [LogWrapper](#logwrapper)
  - [Middleware](#middleware)
  - [OptionsHandler](#optionshandler)
  - [Reader](#reader)
  - [Transformer](#transformer)
  - [Validator](#validator)
  - [Writer](#writer)
  - [Options : <code>object</code>](#options--codeobjectcode)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# jy-transform 

This project aims to read, write and transform [YAML](http://http://yaml.org/), [JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript) or [JSON](http://json.org) objects into each other using CLI or API. The source and destination resources can be files, objects or streams. Besides the transformation feature this module can also be used for simple loading and/or writing YAML, JS or JSON files.

## Installation

Download node at [nodejs.org](http://nodejs.org) and install it, if you haven't already.

```sh
npm install jy-transform --global
```


## Tests

```sh
npm install
npm test
```

## Dependencies

- [bluebird](https://github.com/petkaantonov/bluebird): Full featured Promises/A+ implementation with exceptionally good performance
- [cli](https://github.com/chriso/cli): A tool for rapidly building command line apps
- [is-stream](https://github.com/sindresorhus/is-stream): Check if something is a Node.js stream
- [js-yaml](https://github.com/nodeca/js-yaml): YAML 1.2 parser and serializer
- [json-stringify-safe](https://github.com/isaacs/json-stringify-safe): Like JSON.stringify, but doesn&#39;t blow up on circular refs.
- [mkdirp-then](https://github.com/fs-utils/mkdirp-then): mkdirp as promised
- [serialize-js](https://github.com/RReverser/serialize-js): User-readable object serialization for JavaScript.

## Dev Dependencies

- [codecov](https://github.com/codecov/codecov-node): Uploading report to Codecov: https://codecov.io
- [coveralls](https://github.com/nickmerwin/node-coveralls): takes json-cov output into stdin and POSTs to coveralls.io
- [doctoc](https://github.com/thlorenz/doctoc): Generates TOC for markdown files of local git repo.
- [fs-extra](https://github.com/jprichardson/node-fs-extra): fs-extra contains methods that aren&#39;t included in the vanilla Node.js fs package. Such as mkdir -p, cp -r, and rm -rf.
- [istanbul](https://github.com/gotwarlost/istanbul): Yet another JS code coverage tool that computes statement, line, function and branch coverage with module loader hooks to transparently add coverage when running tests. Supports all JS coverage use cases including unit tests, server side functional tests 
- [jsdoc-parse](https://github.com/jsdoc2md/jsdoc-parse): Jsdoc-annotated source code in, JSON format documentation out.
- [jsdoc-to-markdown](https://github.com/jsdoc2md/jsdoc-to-markdown): jsdoc-annotated source in, markdown API docs out.
- [mocha](https://github.com/mochajs/mocha): simple, flexible, fun test framework
- [mocha-lcov-reporter](https://github.com/StevenLooman/mocha-lcov-reporter): LCOV reporter for Mocha
- [object-path](https://github.com/mariocasciaro/object-path): Access deep properties using a path
- [package-json-to-readme](https://github.com/zeke/package-json-to-readme): Generate a README.md from package.json contents
- [winston](https://github.com/winstonjs/winston): A multi-transport async logging library for Node.js


## License

SEE LICENSE IN [LICENSE.md](https://github.com/deadratfink/jy-transform/blob/master/LICENSE.md)

## Motivation

Why this module? After struggling with some huge YAML file and accidentally 
occurring wrong indentions which results in an annoying failure investigation, 
I decided to get rid of the YAML file and therefore, create a module which 
should be aimed as the swiss army knife for transforming YAML, JS and JSON 
types into each other format.

## Contributing

Pull requests and stars are always welcome. Anybody is invited to take part 
into this project. For bugs and feature requests, please create an 
[issue](https://github.com/deadratfink/jy-transform/issues).
When contributing as coder, please take care of the following conventions:

- Enter yourself in the `constributors` section of _package.json_.
- We strictly follow [Semantic Versioning 2](http://semver.org) rules.
- The `development` branch is the leading branch and is protected. Create bugfix and feature 
  branches (or fork into you own namespace) and create pull 
  requests to `development` when finished. Any of these should be prefixed with 
  `bugfix/#...` or `feature/#...` (followed by issue number and a short, "underscored" 
  proper meaning), e.g. 
  - `bugfix/#8_fix_js_reading_with_require`
  - `feature/#14_multidocument_support`
- Remember that name could need to be enclosed in quotes, e.g. 
  ```$ git checkout -b 'feature/#19_...'```
  when using git shell command.
- The `master` branch is protected and is the stable branch after a release. 
  It will never be pushed directly (only on release build).
- Indention for any file is 4 SPACEs.
- Keep code coverage high (> 95%).
- Doc everything with [JSDocs](http://usejsdoc.org/) and document concepts in 
  [README.md](https://github.com/deadratfink/jy-transform/blob/development/README.md)
  or [Wiki](https://github.com/deadratfink/jy-transform/wiki).
- Use single parenthesis (`'...'`) in _*.js_ files instead of double parenthesis (`"..."`).
- Avoid the of use parenthesis for keys in JSON objects.
- Use the strict mode (`'use strict';`) in _*.js_ files.
- File names should be lower-case with hyphens as divider, e.g. _options-handler.js_.
- Markdown documentation files should be upper-case with _.md_ as extension, placed 
  in _./docs_, e.g. _USAGE.md_. The _README.md_ is build up by these files concatenated 
  by `npm run docs` command. Any new files have to be added to `scripts.docs` section of 
  _package.json_. Don't forget to regenerate _README.md_ before committing.

# Usage

The module can be used on CLI or as API (the latter is fully [Promise](http://bluebirdjs.com/docs/api-reference.html) 
based).

## Usage Types

Since the module can be used in two different ways, use installation as follows:

- CLI: install globally via `-g` option
- API: install locally

Both usage types are described in more detail in the following sections.

## Use Cases

So, what are the typical use cases for this module? In terms of _transformation_
these consists of different phases:

- Reading files (`Reader`)
- Transforming JSON objects (`Transformer`)
- Apply dedicated actions on the intermediate JSON objects (`Transformer` + `Middleware`)
- Writing files (`Writer`)

### Reading

Reading from:

- _*.yaml_ file
- _*.js_ file
- _*.json_ file
- `stream.Readable` (requires `options.origin` property set)
- any JS object (actually, this mean read phase is skipped, because object is in-memory already)

### Transformation

The transformation can take place into several directions:

- YAML -> JS
- YAML -> JSON
- JS   -> YAML
- JSON -> YAML 
- JS   -> JSON 
- JSON -> JS 
- YAML -> YAML     
- JSON -> JSON
- JS   -> JS       

while:

- YAML = _*.yaml_, _*.yml_
- JS   = _*.js_   (JSON object)  
- JSON = _*.json_ (JSON serialized)

### Middleware

Apply actions on the intermediate JSON object via injected [Promise](http://bluebirdjs.com/docs/api-reference.html) 
functions. This is an optional part for [transformation](#transformation) phase.

### Writing

Writing to:

- _*.yaml_ file
- _*.js_ file
- _*.json_ file
- `stream.Writable`  (requires `options.target` property set)
- any JS object

## Limitations

- Since this module is build to transform from and to different type formats, any 
  `Function`s residing in JS type objects are _not_ supported, e.g. transforming
  ```javascript
  module.exports = {
      myKey1: 'value1',
      myFunction: 'value2'
  }
  ```
  to JSON would simply result in 
  ```javascript
  {
      myKey1: 'value1'
  }
  ```
  while transforming to YAML type would even result in an `Error`, e.g. printed 
  on CLI usage like this:
  ```
  ERROR: YAMLException: unacceptable kind of an object to dump [object Function]
  ```
- Multidocument handling would be a cool feature which refers in general to YAML 
  and JS only, but at the moment we require that each document to transform is a 
_single_ one per file! This feature is planned and reflected 
 in [#14](https://github.com/deadratfink/jy-transform/issues/14).
- Schema validation for input and output is another topic which is planned by 
  [#1](https://github.com/deadratfink/jy-transform/issues/1) and 
  [#2](https://github.com/deadratfink/jy-transform/issues/2).

## CLI Usage

The CLI provides the `jyt` command (actually, this requires the use of options). 
After the global installation you can access the `Transformer` command options with the help 
command as follows:

```
$ jyt --help
```

### CLI Options

The `--help` option prints an overview about all available CLI properties:

```
$ jyt --help
Usage:
  jyt [OPTIONS]

Options: 
  -o, --origin [STRING]  The conversion origin: [ js | json | yaml ]. (Default is : if not given, the type is tried to be inferred from the extension of source path, else it is yaml)
  -t, --target [STRING]  The conversion target: [ js | json | yaml ]. (Default is : if not given, the type is tried to be inferred from the extension of destination path, else it is js)
  -s, --src PATH         The absolute/relative input file path.
  -d, --dest [PATH]      The absolute/relative output file path. When this 
                         options is ommited then the output file is stored 
                         relative to the input file (same base name but with 
                         another extension if type differs). If input and 
                         output type are the same then the file overwriting is 
                         handled depending on the '--force' value!  (Default is storing relative to input file)
  -i, --indent [NUMBER]  The indention for pretty-print: 1 - 8.  (Default is 4)
  -f, --force            Force overwriting of existing output files on write 
                         phase. When files are not overwritten (which is 
                         default), then the next transformation with same 
                         output file name gets a consecutive number on the base 
                         file name, e.g. in case of foo.yaml it would be 
                         foo(1).yaml. 
  -x, --exports STRING   Define a 'module.exports[.identifier] = ' 
                         identifier, for usage in JS destination files only 
                         and must be a valid JS identifier! 
  -k, --no-color         Omit color from output
      --debug            Show debug information
  -v, --version          Display the current version
  -h, --help             Display help and usage details
```

These are more formally defined in the following table: 

| Option (short) | Option (long) | Type | Description | Default | Required |
| --- | --- | --- | --- | --- | --- |
| `-o` | `--origin` | [ _js_ &#124; _json_ &#124; _yaml_ ]</code> | The transformation origin type. | if not given, the type is tried to be inferred from the extension of source path, else it is _yaml_ | no |
| `-t` | `--target` | [ _js_ &#124; _json_ &#124; _yaml_ ]</code> | The transformation target type. | if not given, the type is tried to be inferred from the extension of destination path, else it is _js_ | no |
| `-s` | `--src` | URI | The source file path for transformation. | - | yes |
| `-d` | `--dest` | URI | The destination file path to transform to. | When this options is ommited then the output file is stored relative to the input file (same base name but with another extension if type differs). If input and output type are the same then the file overwriting is handled depending on the `--force` value! | no |
| `-i` | `--indent` | integer<br> - [ _1_-_8_ ]<br> | The code indention used in destination files. | _4_ | no |
| `-f` | `--force` | n/a | Force overwriting of existing output files on write phase. When files are not overwritten (which is default), then the next transformation with same output file name gets a consecutive number on the base file name, e.g. in case of foo.yaml it would be foo(1).yaml.  | _false_ | no |
| `-x` | `--exports` | string | Define a 'module.exports[.identifier] = ' identifier, for usage in JS destination files only and must be a valid JS identifier!  | _undefined_ | no |
| `-k` | `--no-color` | n/a | Omit color from output. | _color_ | no |
|  n/a | `--debug` | n/a | Show debug information. | _false_ | no |
| `-v` | `--version` | n/a | Display the current version. | n/a | no |
| `-h` | `--help` | n/a | Display help and usage details. | n/a | no |

**NOTE:** an invalid indention setting (_1_ > `-i`, `--indent` < _8_) does not raise an error but a default of _4_ SPACEs is applied instead.

### Examples

Now we know which properties we can apply on CLI, so let's assume we 
have a YAML file located in _./foo.yaml_ holding this data:

```yaml
foo: bar
```
#### Example: YAML -> JSON

then we can transform it to a JSON file _foo.json_

```javascript
{
  "foo": "bar"
}
```

using this command:

```
$ jyt -s foo.yaml -t json -i 2
```

In this example we have overwritten the standard target type (which is `js`) 
and applying an indent of _2_ instead of the default _4_. As default the output 
file _foo.json_ is written relative to the input file (simply omitting the 
`dest` option here).

**NOTE:** here you _have_ to provide the target with `-t json` or else the 
default `js` would have been applied! If the source would have been a `js` 
type like

```
$ jyt -s foo.js -t json -i 2
```

then the `js` value for `origin` is automatically inferred from file extension. 
Accordingly, this is also true for the `target` option.

#### Example: JSON -> JS

```
$ jyt -s foo.json -i 2
```
```javascript
module.exports = {
  foo: "bar"
}
```

#### Example: JS -> YAML

```
$ jyt -s foo.json -t yaml
```
```yaml
foo: bar
```

#### Example: Transformation with Different Destination

Simply provide the `-d` with a different file name:

```
$ jyt -s foo.json -d results/foobar.yaml
```

#### Example: Transformation with Unsupported Source File Extension

As said, normally we infer from file extension to the type but assume the source 
file has a file name which does not imply the type (here JS 
type in a TEXT file), then you can simply provide the `-o` option with the 
correct `origin` type (of course, the `-t` option works analogous):


```
$ jyt -s foo.txt -o js -d foobar.yaml
```

#### Example: Write Exports Identifier for JS File

Assume you want to generate a JS file with an exports string which gets an 
identifier. We reuse the YAML file from above 

```yaml
foo: bar
```

using this command:

```
$ jyt -s foo.yaml -d foobar.js -x foobar
```

This generates the following output in JS file using `foobar` as identifier:

```javascript
module.exports.foobar = {
    foo: "bar"
}
```

**NOTE:** the identifier must be a valid JS identifier accoding to ECMAScript 6
(see also [Valid JavaScript variable names in ECMAScript 6](https://mathiasbynens.be/notes/javascript-identifiers-es6) 
and [Generating a regular expression to match valid JavaScript identifiers](https://mathiasbynens.be/demo/javascript-identifier-regex)).

#### Example: Force Overwriting

**IMPORTANT NOTE:** any subsequent execution using the same target/file name, 
will overwrite the original source or target created beforehand!

By default this feature is not enbled to prevent you from accidentially 
overwriting your input source or already generated targets.

But let's say we want to overwrite the original source now because you want 
to change the indention from 2 to 4 SPACEs, then we can do this as follows:

```
$ jyt -s foo.js -f
```

This would change the indention from 2 (created in example before) to 4 

Of course, leaving out the `-f` switch creates a new file relatively to 
the origin named _foo(1).js_ (note the consecutive number)! Naturally, 
another run of the command would result int a file called _foo(2).js_ 
and so forth.

## Origin and Target Type Inference

The examples above have shown that we have an automatic type inference from file 
extensions. This is supported as shown by the following table (from-to):

| File Extension | Type |
| --- | --- |
| _*.yaml_ | _yaml_ |
| _*.yml_ | _yaml_ |
| _*.js_ | _js_ |
| _*.json_ | _json_ |

**NOTE:** if you have files without an extension or e.g. _*.txt_ you _have_ to 
specify the origin or target type!

## API Usage

Since the usage on CLI is a 2-step process:

1. Read source file in to JSON object -> 
2. Write out (to another type)

the direct API calls additionally provide the usage of a _middleware_ function 
where you can alter the input JSON object before it is written and therefore, which turns 
this into a 3-step process:
 
1. Read source file in -> 
2. Alter the JSON object -> 
3. Write out (to another type)

For more details about this and all the functions provided by this module please refer to the 
[API Reference](#api-reference) below.

The `origin` and `target` type inference is also standard for the API level.

### API Properties

The `Transformer` exposes the following function which takes besides an (optional) 
`middleware` function the necessary `options` for the transformation:

```javascript
function transform(options, middleware)
```

The `options` object has to follow this key-values table:

| Option | Type | Description | Default | Required |
| --- | --- | --- | --- | --- |
| origin | <code>string</code> | The origin type. | If not given, the type is tried to be inferred from the extension of source path, else it is _yaml_. | no |
| target | <code>string</code> | The target type. | If not given, the type is tried to be inferred from the extension of destination path, else it is _js_ | no |
| src | <code>string &#124; Readable &#124; object</code> | The source information object: `string` is used as file path, `Readable` stream provides a stringified source and `object` is used as direct JS source. | - | yes |
| dest | <code>string &#124; Writable &#124; object</code> | The destination information object: `string` is used as file path, `Writable` stream writes a stringified source and `object` is used as direct JS object for assignment. | The output file is stored relative to the input file (same base name but with another extension if type differs). If input and output type are the same then the file overwriting is handled depending on the 'force' value! | no |
| indent | <code>number</code> | The indention in files. | _4_ | no |
| force | <code>boolean</code> | Force overwriting of existing output files on write phase. When files are not overwritten, then the next transformation with same output file name gets a consecutive number on the base file name, e.g. in case of _foo.yaml_ it would be _foo(1).yaml_. | _false_ | no |
| exports | <code>string</code> | Define a 'module.exports[.identifier] = ' identifier, for usage in JS destination files only and must be a valid JS identifier! | _undefined_ | no |

**NOTE:** an invalid indention setting (_1_ > indent < _8_) does not raise an error but a default of _4_ SPACEs is applied instead.

#### Example

```javascript
var options = {
    origin: 'json',
    target: 'yaml',
    src: 'foo.json',
    dest: './foo/bar.yaml',
    indent: 2
}
```

### Using Middleware

The `middleware` is optional but if provided it must be of type `Function` and 
a [Promise](http://bluebirdjs.com/docs/api-reference.html). One of the easiest 
ones is the identity function 

_f(data) -> data_ 

which could be expressed as 
[Promise](http://bluebirdjs.com/docs/api-reference.html) function as follows:

```javascript
var middleware = function (json) {
    return Promise.resolve(json);
}
```

Of course, this would have no effect on the provided JSON data. Actually, this one is 
used internally when no middleware is provided to ensure the proper promised 
control flow.

OK, lets go back to a more practical example, e.g. we want to alter the value of
JSON property before it is written to a file. Assuming we have this piece of YAML
object as input:

```yaml
foo: old bar
```

Applying this [Promise](http://bluebirdjs.com/docs/api-reference.html) as middleware

```javascript
var middleware = function (json) {
    json.foo = 'new bar'; 
    return Promise.resolve(json);
}

transformer.transform(options, middleware)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```

will result in such JSON file:

```javascript
{
	"foo": "new bar"
}
```

Of course, in real world scenarios you will have use cases which usually have a 
higher complexity where one function might be insufficient or at least 
inconvenient. but this does not raise a problem at all, because you can create 
several functions to be applied in the whole transformation process by gathering 
them in one function.

Let's assume we have some Promise functions to apply. For simplicity reasons we 
simulate these for the moment by three functions, each adding a key-value to the 
given (initially empty) JSON object.

**NOTE:** each of them has to resolve with the `json` object! 


```javascript
function key1(json) {
    objectPath.set(json, 'key1', 'value1');
    return Promise.resolve(json);
}

function key2(json) {
    objectPath.set(json, 'key2', 'value2');
    return Promise.resolve(json);
}

function key3(json) {
    objectPath.set(json, 'key3', 'value3');
    return Promise.resolve(json);
}
```

These can be collected by different aggregation or composition functions of the underlying
Promise framework, e.g. using the  [`Promise.all([...])`](http://bluebirdjs.com/docs/api/promise.all.html) 
function. This one can collect all three functions above and ensure their proper subsequent execution:

 
```javascript
var middleware = function (json) {
    return Promise.all([key1(json), key2(json), key3(json)])
        .then(function(result) {
            return Promise.resolve(result[result.length - 1]);
        });
};

var transformer = new Transformer(logger);
var logger = ...;
var options = {...};

return transformer.transform(options, middleware)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```

Then the result in the `middleware` function can be retrieved from the returned 
array, i.e. in case of [`Promise.all([...])`](http://bluebirdjs.com/docs/api/promise.all.html) 
you have to pick the _last_ element which contains the "final product". 
From our example above it would be

```javascript
{
    key1: 'value1',
    key2: 'value2',
    key3: 'value3'
}
```

which then is passed back to the transformation chain. Following this pattern 
you can do almost everything with the JSON object, like

- deleting properties
- changing properties to other types
- validating and throwing error if not valid
- ...

Whatever you do during transformation, just keep it valid ;-)

## Using Custom Logger

It is usual that you use an own `logger` in your application. This module supports you by 
letting you inject your logger as constructor argument: the `Reader`, `Transformer` and 
`Writer` constructor will accept an (optional) logger object.

If you do not provide one, then the default logger is `console`.

```javascript
var logger = ...;

var reader = new Reader(logger);
var transformer = new Transformer(logger);
var writer = new Writer(logger);
```

At least, the passed logger object _has to_ support the following functions:

```javascript
function info(msg)
function debug(msg)
function error(msg)
```

---

For more details refer to the [API Reference](#api-reference) section which describes 
the full API and provides more examples.

# API Reference

## Classes

<dl>
<dt><a href="#Constants">Constants</a></dt>
<dd><p>Class which defines all constants usable in or with this module.</p>
</dd>
<dt><a href="#LogWrapper">LogWrapper</a></dt>
<dd><p>Class which defines a <code>logger</code> wrapper usable in this module.
       <p>
       <strong>NOTE:</strong> This class is not to be intended to be called from
       outside this module!</p>
</dd>
<dt><a href="#Middleware">Middleware</a></dt>
<dd><p>Class which defines middleware Promises usable in or with this module.</p>
</dd>
<dt><a href="#OptionsHandler">OptionsHandler</a></dt>
<dd><p>Class which defines some useful methods to initialize and prepare the
       transformation options used in this module.
       <p>
       <strong>NOTE:</strong> This class is not to be intended to be called from
       outside this module!</p>
</dd>
<dt><a href="#Reader">Reader</a></dt>
<dd><p>This class provides utility methods usable to read YAML, JSON or JS
       from a file to JS memory objects.</p>
</dd>
<dt><a href="#Transformer">Transformer</a></dt>
<dd><p>This class provides all methods usable to handle YAML, JSON and JS and
       their transformations.</p>
</dd>
<dt><a href="#Validator">Validator</a></dt>
<dd><p>This class validates JSON.</p>
</dd>
<dt><a href="#Writer">Writer</a></dt>
<dd><p>This class provides utility methods usable to write JSON/JS/YAML
       from memory to a JSON/JS/YAML file.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#Options">Options</a> : <code>object</code></dt>
<dd></dd>
</dl>

<a name="Constants"></a>
## Constants
Class which defines all constants usable in or with this module.

**Kind**: global class  

* [Constants](#Constants)
    * [new Constants()](#new_Constants_new)
    * [.DEFAULT_ORIGIN](#Constants+DEFAULT_ORIGIN) : <code>string</code>
    * [.DEFAULT_TARGET](#Constants+DEFAULT_TARGET) : <code>string</code>
    * [.DEFAULT_FORCE_FILE_OVERWRITE](#Constants+DEFAULT_FORCE_FILE_OVERWRITE) : <code>boolean</code>
    * [.ORIGIN_DESCRIPTION](#Constants+ORIGIN_DESCRIPTION) : <code>string</code>
    * [.TARGET_DESCRIPTION](#Constants+TARGET_DESCRIPTION) : <code>string</code>
    * [.DEST_DESCRIPTION](#Constants+DEST_DESCRIPTION) : <code>string</code>
    * [.DEFAULT_JS_FILE_EXPORTS_IDENTIFIER](#Constants+DEFAULT_JS_FILE_EXPORTS_IDENTIFIER) : <code>string</code>
    * [.DEFAULT_OPTIONS](#Constants+DEFAULT_OPTIONS) : <code>object</code>
    * [.UTF8](#Constants+UTF8) : <code>string</code>
    * [.YAML](#Constants+YAML) : <code>string</code>
    * [.JSON](#Constants+JSON) : <code>string</code>
    * [.JS](#Constants+JS) : <code>string</code>
    * [.TYPES](#Constants+TYPES) : <code>Array.&lt;string&gt;</code>
    * [.DEFAULT_INDENT](#Constants+DEFAULT_INDENT) : <code>number</code>
    * [.MIN_INDENT](#Constants+MIN_INDENT) : <code>number</code>
    * [.MAX_INDENT](#Constants+MAX_INDENT) : <code>number</code>
    * [.YAML_TO_JS](#Constants+YAML_TO_JS) : <code>string</code>
    * [.YAML_TO_JSON](#Constants+YAML_TO_JSON) : <code>string</code>
    * [.JS_TO_YAML](#Constants+JS_TO_YAML) : <code>string</code>
    * [.JSON_TO_YAML](#Constants+JSON_TO_YAML) : <code>string</code>
    * [.JSON_TO_JS](#Constants+JSON_TO_JS) : <code>string</code>
    * [.JS_TO_JSON](#Constants+JS_TO_JSON) : <code>string</code>
    * [.YAML_TO_YAML](#Constants+YAML_TO_YAML) : <code>string</code>
    * [.JSON_TO_JSON](#Constants+JSON_TO_JSON) : <code>string</code>
    * [.JS_TO_JS](#Constants+JS_TO_JS) : <code>string</code>
    * [.TRANSFORMATIONS](#Constants+TRANSFORMATIONS) : <code>Array.&lt;string&gt;</code>

<a name="new_Constants_new"></a>
### new Constants()
Constructs the constants.

**Returns**: <code>[Constants](#Constants)</code> - - The instance.  
<a name="Constants+DEFAULT_ORIGIN"></a>
### constants.DEFAULT_ORIGIN : <code>string</code>
The default origin value: 'yaml'.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+DEFAULT_TARGET"></a>
### constants.DEFAULT_TARGET : <code>string</code>
The default origin value: 'js'.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+DEFAULT_FORCE_FILE_OVERWRITE"></a>
### constants.DEFAULT_FORCE_FILE_OVERWRITE : <code>boolean</code>
Whether to overwrite existing file or object on output.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+ORIGIN_DESCRIPTION"></a>
### constants.ORIGIN_DESCRIPTION : <code>string</code>
The origin description value.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+TARGET_DESCRIPTION"></a>
### constants.TARGET_DESCRIPTION : <code>string</code>
The target description value.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+DEST_DESCRIPTION"></a>
### constants.DEST_DESCRIPTION : <code>string</code>
The dest description value.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+DEFAULT_JS_FILE_EXPORTS_IDENTIFIER"></a>
### constants.DEFAULT_JS_FILE_EXPORTS_IDENTIFIER : <code>string</code>
The dest description value.

**Kind**: instance property of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+DEFAULT_OPTIONS"></a>
### constants.DEFAULT_OPTIONS : <code>object</code>
The default options.

**Kind**: instance namespace of <code>[Constants](#Constants)</code>  
**See**

- [ORIGIN_DESCRIPTION](#Constants+ORIGIN_DESCRIPTION)
- [TARGET_DESCRIPTION](#Constants+TARGET_DESCRIPTION)
- [DEST_DESCRIPTION](#Constants+DEST_DESCRIPTION)

**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| origin | <code>string</code> | <code>&quot;yaml&quot;</code> | The default origin type. |
| target | <code>string</code> | <code>&quot;js&quot;</code> | The default target type. |
| dest | <code>string</code> | <code>&quot;&#x27;relative&quot;</code> | to input file' - The default dest description. |
| indent | <code>number</code> | <code>4</code> | The default indention for files. |
| force | <code>boolean</code> | <code>false</code> | Whether to overwrite existing file on output. |
| exports | <code>string</code> |  | The exports name for usage in JS files only. |

<a name="Constants+UTF8"></a>
### constants.UTF8 : <code>string</code>
The 'utf8' constant.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+YAML"></a>
### constants.YAML : <code>string</code>
The 'yaml' type constant.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JSON"></a>
### constants.JSON : <code>string</code>
The 'json' type constant.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JS"></a>
### constants.JS : <code>string</code>
The 'js' type constant.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+TYPES"></a>
### constants.TYPES : <code>Array.&lt;string&gt;</code>
The type constants assembled in an array: `[ 'yaml', 'json', 'js' ]`.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+DEFAULT_INDENT"></a>
### constants.DEFAULT_INDENT : <code>number</code>
The default file indention (4 SPACEs).

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+MIN_INDENT"></a>
### constants.MIN_INDENT : <code>number</code>
The minimum file indention (0 SPACE).

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+MAX_INDENT"></a>
### constants.MAX_INDENT : <code>number</code>
The maximum file indention (8 SPACEs).

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+YAML_TO_JS"></a>
### constants.YAML_TO_JS : <code>string</code>
The transformation direction YAML -> JS.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+YAML_TO_JSON"></a>
### constants.YAML_TO_JSON : <code>string</code>
The transformation direction YAML -> JSON.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JS_TO_YAML"></a>
### constants.JS_TO_YAML : <code>string</code>
The transformation direction JS -> YAML.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JSON_TO_YAML"></a>
### constants.JSON_TO_YAML : <code>string</code>
The transformation direction JSON -> YAML.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JSON_TO_JS"></a>
### constants.JSON_TO_JS : <code>string</code>
The transformation direction JSON -> JS.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JS_TO_JSON"></a>
### constants.JS_TO_JSON : <code>string</code>
The transformation direction JS -> JSON.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+YAML_TO_YAML"></a>
### constants.YAML_TO_YAML : <code>string</code>
The transformation direction YAML -> YAML.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JSON_TO_JSON"></a>
### constants.JSON_TO_JSON : <code>string</code>
The transformation direction JSON -> JSON.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+JS_TO_JS"></a>
### constants.JS_TO_JS : <code>string</code>
The transformation direction JS -> JS.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="Constants+TRANSFORMATIONS"></a>
### constants.TRANSFORMATIONS : <code>Array.&lt;string&gt;</code>
The transformation directions.

**Kind**: instance constant of <code>[Constants](#Constants)</code>  
**Access:** public  
<a name="LogWrapper"></a>
## LogWrapper
Class which defines a `logger` wrapper usable in this module.
       <p>
       **NOTE:** This class is not to be intended to be called from
       outside this module!

**Kind**: global class  

* [LogWrapper](#LogWrapper)
    * [new LogWrapper([logger])](#new_LogWrapper_new)
    * [.debug(msg)](#LogWrapper+debug)
    * [.info(msg)](#LogWrapper+info)
    * [.error(msg)](#LogWrapper+error)
    * [.verboseOptions(options)](#LogWrapper+verboseOptions) ⇒

<a name="new_LogWrapper_new"></a>
### new LogWrapper([logger])
Constructs the `LogWrapper`.

**Returns**: <code>[LogWrapper](#LogWrapper)</code> - - The instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [logger] | <code>logger</code> &#124; <code>cli</code> &#124; <code>console</code> | <code>console</code> | Logger object. |

**Example**  
```js
var logger = ...;
var logWrapper = new LogWrapper(logger);
```
<a name="LogWrapper+debug"></a>
### logWrapper.debug(msg)
Log the options with DEBUG level (logger supports it, else with INFO).

**Kind**: instance method of <code>[LogWrapper](#LogWrapper)</code>  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| msg | <code>string</code> | The message to log. |

**Example**  
```js
var logger = ...;
var logWrapper = new LogWrapper(logger);
var msg = '...';
logWrapper.debug(msg);
```
<a name="LogWrapper+info"></a>
### logWrapper.info(msg)
Log the options with INFO level.

**Kind**: instance method of <code>[LogWrapper](#LogWrapper)</code>  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| msg | <code>string</code> | The message to log. |

**Example**  
```js
var logger = ...;
var logWrapper = new LogWrapper(logger);
var msg = '...';
logWrapper.info(msg);
```
<a name="LogWrapper+error"></a>
### logWrapper.error(msg)
Log the options with ERROR level.

**Kind**: instance method of <code>[LogWrapper](#LogWrapper)</code>  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| msg | <code>string</code> | The message to log. |

**Example**  
```js
var logger = ...;
var logWrapper = new LogWrapper(logger);
var msg = '...';
logWrapper.error(msg);
```
<a name="LogWrapper+verboseOptions"></a>
### logWrapper.verboseOptions(options) ⇒
Log the options with INFO level.

**Kind**: instance method of <code>[LogWrapper](#LogWrapper)</code>  
**Returns**: A Promise containing the passed `options` object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The properties to log with INFO. |

**Example**  
```js
var logger = ...;
var logWrapper = new LogWrapper(logger);
var options = {
    ...
};
logWrapper.verboseOptions(options)
    .then(function (options) {
        ...
    });
```
<a name="Middleware"></a>
## Middleware
Class which defines middleware Promises usable in or with this module.

**Kind**: global class  

* [Middleware](#Middleware)
    * [new Middleware()](#new_Middleware_new)
    * [.identityMiddleware](#Middleware+identityMiddleware)
    * [.ensureMiddleware(middleware)](#Middleware+ensureMiddleware) ⇒ <code>Promise</code>

<a name="new_Middleware_new"></a>
### new Middleware()
Constructs the `Middleware`.

**Returns**: <code>[Middleware](#Middleware)</code> - - The instance.  
**Example**  
```js
var middleware = require('./lib/middleware.js');
```
<a name="Middleware+identityMiddleware"></a>
### middleware.identityMiddleware
Middleware Promise which reflects the identity of passed JSON: `f(json) -> json`.

**Kind**: instance property of <code>[Middleware](#Middleware)</code>  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>object</code> | The data which is returned in Promise. |

**Example**  
```js
var middleware = require('./lib/middleware.js');
var identityMiddleware = middleware.identityMiddleware;
transformer.transform(options, identityMiddleware)
    .then(function(json) {
        ...
    }):
```
<a name="Middleware+ensureMiddleware"></a>
### middleware.ensureMiddleware(middleware) ⇒ <code>Promise</code>
Ensure that the given middleware Promise is a function if set.
If not set a new JSON 'identity' Promise is returned which simply passes
a JSON object.

**Kind**: instance method of <code>[Middleware](#Middleware)</code>  
**Returns**: <code>Promise</code> - The given middleware Promise or a new JSON 'identity' middleware Promise.  
**Throws**:

- <code>TypeError</code> Will throw this error when the passed `middleware`
        is not type of `Function`.

**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| middleware | <code>function</code> | This middleware Promise can be used to intercept        the JSON object for altering he passed JSON, the function signature is:        ```        function(json)        ```        The Promise has to return the processed JSON! |

**Example**  
```js
var middleware = require('./lib/middleware.js');
var myMiddleware = function(json) {
    ...
};
transformer.transform(options, middleware.ensureMiddleware(myMiddleware))
    .then(function(json) {
        ...
    }):
```
<a name="OptionsHandler"></a>
## OptionsHandler
Class which defines some useful methods to initialize and prepare the
       transformation options used in this module.
       <p>
       **NOTE:** This class is not to be intended to be called from
       outside this module!

**Kind**: global class  

* [OptionsHandler](#OptionsHandler)
    * [new OptionsHandler([logger])](#new_OptionsHandler_new)
    * [.assertOptions](#OptionsHandler+assertOptions) ⇒ <code>Promise</code>
    * [.completeOptions(options)](#OptionsHandler+completeOptions) ⇒ <code>Promise</code>
    * [.ensureSrc(options)](#OptionsHandler+ensureSrc) ⇒ <code>Promise</code>
    * [.ensureDest(options)](#OptionsHandler+ensureDest) ⇒ <code>Promise</code>
    * [.assertOrigin(options)](#OptionsHandler+assertOrigin) ⇒ <code>Promise</code>
    * [.assertTarget(options)](#OptionsHandler+assertTarget) ⇒ <code>Promise</code>
    * [.ensureIndent(options)](#OptionsHandler+ensureIndent) ⇒ <code>Promise</code>
    * [.ensureOptions(options)](#OptionsHandler+ensureOptions) ⇒ <code>Promise</code>
    * [.validateTransformation(options)](#OptionsHandler+validateTransformation) ⇒ <code>Promise</code>

<a name="new_OptionsHandler_new"></a>
### new OptionsHandler([logger])
Constructs the `OptionsHandler` with an (optional) logger.

**Returns**: <code>[OptionsHandler](#OptionsHandler)</code> - The instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [logger] | <code>logger</code> &#124; <code>cli</code> &#124; <code>console</code> | <code>console</code> | Logger object. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;

var optionsHandler = new OptionsHandler(logger);
```
<a name="OptionsHandler+assertOptions"></a>
### optionsHandler.assertOptions ⇒ <code>Promise</code>
Asserts that the given `options` and (optionally) the given properties are
inside the options. If not, the Promise rejects with proper error message.

**Kind**: instance property of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - Promise which contains the `options` as result.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>object</code> | The objects which should be set. |
| [properties] | <code>Array.&lt;string&gt;</code> | Properties which should exist in `options`. |

**Example**  
```js
var options = {...};

assertOptions(options, ['src', 'origin'])
    .then(function (assertedOptions) {
        ...
    });
```
<a name="OptionsHandler+completeOptions"></a>
### optionsHandler.completeOptions(options) ⇒ <code>Promise</code>
Completes the given `options` object by enriching from default values or using
type inference if something required is "missing" (a missing `options.src` cannot
be completed becaue this is mandatory).

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object.  
**Throws**:

- <code>Error</code> - If `options` or `options.src` not passed.

**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.completeOptions(options)
    .then(function (copiedOptions) {
        ...
    });
```
<a name="OptionsHandler+ensureSrc"></a>
### optionsHandler.ensureSrc(options) ⇒ <code>Promise</code>
Ensures that the given input source is valid.

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object.  
**Throws**:

- <code>Error</code> - If the `options.src` is not defined or the file represented by `options.src` does not exist.

**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.ensureSrc(options)
    .then(function (ensuredOptions) {
        ...
    });
```
<a name="OptionsHandler+ensureDest"></a>
### optionsHandler.ensureDest(options) ⇒ <code>Promise</code>
This method ensures that destination file path is created if not set in
options. If not, then it creates the path relative to the source file using
its name and appending a proper extension depending on the `json`
property of `options` (if `true` then '.js', else '.json').

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.ensureDest(options)
    .then(function (ensuredOptions) {
        ...
    });
```
<a name="OptionsHandler+assertOrigin"></a>
### optionsHandler.assertOrigin(options) ⇒ <code>Promise</code>
Checks if the given origin is valid.

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.assertOrigin(options)
    .then(function (ensuredOptions) {
        ...
    });
```
<a name="OptionsHandler+assertTarget"></a>
### optionsHandler.assertTarget(options) ⇒ <code>Promise</code>
Checks if the given target is valid.

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.assertTarget(options)
    .then(function (ensuredOptions) {
        ...
    });
```
<a name="OptionsHandler+ensureIndent"></a>
### optionsHandler.ensureIndent(options) ⇒ <code>Promise</code>
Checks if a valid indention value is given and corrects values if invalid (with default value: 4 SPACEs).

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object.  
**Access:** public  
**See**

- [MIN_INDENT](#Constants+MIN_INDENT)
- [DEFAULT_INDENT](#Constants+DEFAULT_INDENT)
- [MAX_INDENT](#Constants+MAX_INDENT)


| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.ensureIndent(options)
    .then(function (ensuredOptions) {
        ...
    });
```
<a name="OptionsHandler+ensureOptions"></a>
### optionsHandler.ensureOptions(options) ⇒ <code>Promise</code>
This method ensures that the options object is set with all necessary and
correct values. The method does not alter the given object, but creates
and fills a new instance from the given values and/or default ones.

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing a new and complete `options` object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var options = {...};
var optionsHandler = new OptionsHandler(logger);

optionsHandler.ensureOptions(options)
    .then(function (ensuredOptions) {
        ...
    });
```
<a name="OptionsHandler+validateTransformation"></a>
### optionsHandler.validateTransformation(options) ⇒ <code>Promise</code>
This method validates the transformation process described by the given
options and provides the validate and enriched options and according name
to resolve a proper function.

**Kind**: instance method of <code>[OptionsHandler](#OptionsHandler)</code>  
**Returns**: <code>Promise</code> - - A Promise containing the passed `options` object and a 'transformation' string in an array.  
**Access:** public  
**See**: [transformations](transformations)  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |

**Example**  
```js
var OptionsHandler = require('./options-handler.js');
var logger = ...;
var optionsHandler = new OptionsHandler(logger);

optionsHandler.validateTransformation(options)
    .spread(function (validatedOptions, transformation) {
        ...
    )):
```
<a name="Reader"></a>
## Reader
This class provides utility methods usable to read YAML, JSON or JS
       from a file to JS memory objects.

**Kind**: global class  

* [Reader](#Reader)
    * [new Reader([logger])](#new_Reader_new)
    * _instance_
        * [.readJs(options)](#Reader+readJs) ⇒ <code>Promise</code>
        * [.readYaml(options)](#Reader+readYaml) ⇒ <code>Promise</code>
    * _inner_
        * [~createReadableFunction(src, bufs)](#Reader..createReadableFunction) ⇒ <code>function</code>

<a name="new_Reader_new"></a>
### new Reader([logger])
Constructs the `Reader` with an (optional) logger.

**Returns**: <code>[Reader](#Reader)</code> - The instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [logger] | <code>logger</code> &#124; <code>cli</code> &#124; <code>console</code> | <code>console</code> | Logger object. |

**Example**  
```js
var Reader = require('jy-transform').Reader;
var logger = ...;

var reader = new Reader(logger);
```
<a name="Reader+readJs"></a>
### reader.readJs(options) ⇒ <code>Promise</code>
Reads the data from a given _*.js_ or _*.json_ file source.

**Kind**: instance method of <code>[Reader](#Reader)</code>  
**Returns**: <code>Promise</code> - - Contains the read JSON object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | Contains the JS/JSON source reference to read from. |

**Example**  
```js
var Reader = require('jy-transform').Reader;
var logger = ...;
var options = {
   src: 'foo.js'
};
var reader = new Reader(logger);
reader.readJs(options)
    .then(function (json){
        logger.info(JSON.stringify(json));
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    src: fs.createReadStream('./my.js')
};
reader.readJs(options)
    .then(function (json){
        logger.info(JSON.stringify(json));
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    src: {
        foo: 'bar'
    }
};
reader.readJs(options)
    .then(function (json){
        logger.info(JSON.stringify(json));
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```
<a name="Reader+readYaml"></a>
### reader.readYaml(options) ⇒ <code>Promise</code>
Loads a single YAML file containing document and turns a JS object.

*NOTE:* This function does not understand multi-document sources, it throws
exception on those.

**Kind**: instance method of <code>[Reader](#Reader)</code>  
**Returns**: <code>Promise</code> - - Contains the read JSON object.  
**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | Contains the YAML source reference to read from. |

**Example**  
```js
var Reader = require('jy-transform').Reader;
var logger = ...;

var reader = new Reader(logger);
reader.readYaml('foo.yaml')
    .then(function (json){
        logger.info(JSON.stringify(json));
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    src: fs.createReadStream('foo.yml')
};
reader.readJs(options)
    .then(function (json){
        logger.info(JSON.stringify(json));
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```
<a name="Reader..createReadableFunction"></a>
### Reader~createReadableFunction(src, bufs) ⇒ <code>function</code>
Creates a function to read from the passed source in to the given buffer array.

**Kind**: inner method of <code>[Reader](#Reader)</code>  
**Returns**: <code>function</code> - - The function whic hreads and buffers.  

| Param | Type | Description |
| --- | --- | --- |
| src | <code>stream.Readable</code> | The source to read from. |
| bufs | <code>array</code> | The temporary buffer array. |

<a name="Transformer"></a>
## Transformer
This class provides all methods usable to handle YAML, JSON and JS and
       their transformations.

**Kind**: global class  

* [Transformer](#Transformer)
    * [new Transformer([logger])](#new_Transformer_new)
    * _instance_
        * [.transform(options, [middleware])](#Transformer+transform) ⇒ <code>Promise</code>
    * _inner_
        * [~ensureMiddleware](#Transformer..ensureMiddleware)

<a name="new_Transformer_new"></a>
### new Transformer([logger])
Constructs the `Transformer` with options and an (optional) logger.

**Returns**: <code>[Transformer](#Transformer)</code> - - The instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [logger] | <code>logger</code> &#124; <code>cli</code> &#124; <code>console</code> | <code>console</code> | Logger object. |

**Example**  
```js
var logger = ...;
var Transformer = require('jy-transform');
var transformer = new Transformer(logger);
```
<a name="Transformer+transform"></a>
### transformer.transform(options, [middleware]) ⇒ <code>Promise</code>
The entry method for all transformation accepting a configuration object and
an (optional) middleware function.

**Kind**: instance method of <code>[Transformer](#Transformer)</code>  
**Returns**: <code>Promise</code> - - Containing the transformation result as message (e.g.
         to be logged by caller).  
**Throws**:

- <code>TypeError</code> - Will throw this error when the passed `middleware`
        is not type of `Function`.
- <code>Error</code> - Will throw plain error when writing to file failed due to any reason.

**Access:** public  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>[Options](#Options)</code> | The configuration for a transformation. |
| [middleware] | <code>function</code> | This middleware Promise can be used to intercept        the JSON object for altering the passed JSON, the function signature is:        ```        function(json)        ```        <p>        **NOTE:** the Promise has to return the processed JSON! |

**Example**  
```js
var Transformer = require('jy-transform');
var transformer = new Transformer(logger);
var Promise = require('bluebird');
var logger = ...;
var options = {...};
var middleware = function (json) {
    json.myproperty = 'new value';
    return Promise.resolve(json);
};

transformer.transform(options, middleware)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```
<a name="Transformer..ensureMiddleware"></a>
### Transformer~ensureMiddleware
Ensures that basic middleware is set.

**Kind**: inner property of <code>[Transformer](#Transformer)</code>  
<a name="Validator"></a>
## Validator
This class validates JSON.

**Kind**: global class  

* [Validator](#Validator)
    * [new Validator([logger])](#new_Validator_new)
    * [.validateIdentifier(identifier)](#Validator+validateIdentifier) ⇒ <code>boolean</code>

<a name="new_Validator_new"></a>
### new Validator([logger])
Constructs the `Validator` with an (optional) logger.

**Returns**: <code>[Writer](#Writer)</code> - The instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [logger] | <code>logger</code> &#124; <code>cli</code> &#124; <code>console</code> | <code>console</code> | Logger object. |

**Example**  
```js
var Validator = require('./validator.js');
var logger = ...;

var validator = new Validator(logger);
```
<a name="Validator+validateIdentifier"></a>
### validator.validateIdentifier(identifier) ⇒ <code>boolean</code>
**Kind**: instance method of <code>[Validator](#Validator)</code>  
**Access:** public  

| Param |
| --- |
| identifier | 

**Example**  
```js
var Validator = require('./validator.js');
var logger = ...;
var validator = new Validator(logger);
var identifier = 'foo';

logger.info('valid = ' + validator.validateIdentifier(identifier));
```
<a name="Writer"></a>
## Writer
This class provides utility methods usable to write JSON/JS/YAML
       from memory to a JSON/JS/YAML file.

**Kind**: global class  

* [Writer](#Writer)
    * [new Writer([logger])](#new_Writer_new)
    * [.writeYaml(json, options)](#Writer+writeYaml) ⇒ <code>Promise</code>
    * [.writeJson(json, options)](#Writer+writeJson) ⇒ <code>Promise</code>
    * [.writeJs(json, options)](#Writer+writeJs) ⇒ <code>Promise</code>

<a name="new_Writer_new"></a>
### new Writer([logger])
Constructs the `Writer` with an (optional) logger.

**Returns**: <code>[Writer](#Writer)</code> - The instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [logger] | <code>logger</code> &#124; <code>cli</code> &#124; <code>console</code> | <code>console</code> | Logger object. |

**Example**  
```js
var Writer = require('jy-transform').Writer;
var logger = ...;

var writer = new Writer(logger);
```
<a name="Writer+writeYaml"></a>
### writer.writeYaml(json, options) ⇒ <code>Promise</code>
Writes a JSON object to a _*.yaml_ file.

**Kind**: instance method of <code>[Writer](#Writer)</code>  
**Returns**: <code>Promise</code> - - Containing the write success message to handle by caller (e.g. for logging).  
**Throws**:

- <code>Error</code> - If YAML file could not be written due to any reason.

**Access:** public  
**See**

- [MIN_INDENT](#Constants+MIN_INDENT)
- [DEFAULT_INDENT](#Constants+DEFAULT_INDENT)
- [MAX_INDENT](#Constants+MAX_INDENT)


| Param | Type | Description |
| --- | --- | --- |
| json | <code>object</code> | The JSON to write into _*.yaml_ file. |
| options | <code>[Options](#Options)</code> | The write destination and indention. |

**Example**  
```js
var Writer = require('jy-transform').Writer;
var logger = ...;
var writer = new Writer(logger);

var json = {...},
var options = {
    dest: 'result.yml',
    indent: 2
}

writer.writeYaml(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    dest: fs.createWriteStream('result.yml'),
    indent: 4
}

writer.writeYaml(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```
<a name="Writer+writeJson"></a>
### writer.writeJson(json, options) ⇒ <code>Promise</code>
Writes a JSON object to a _*.json_ file.

**Kind**: instance method of <code>[Writer](#Writer)</code>  
**Returns**: <code>Promise</code> - - Containing the write success message to handle by caller (e.g. for logging).  
**Access:** public  
**See**

- [MIN_INDENT](#Constants+MIN_INDENT)
- [DEFAULT_INDENT](#Constants+DEFAULT_INDENT)
- [MAX_INDENT](#Constants+MAX_INDENT)


| Param | Type | Description |
| --- | --- | --- |
| json | <code>object</code> | The JSON to write into _*.json_ file. |
| options | <code>[Options](#Options)</code> | The write destination and indention. |

**Example**  
```js
var Writer = require('jy-transform').Writer;
var logger = ...;
var writer = new Writer(logger);

var json = {...};
var options = {
    dest: 'result.json',
    indent: 2
}

writer.writeJson(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    dest: fs.createWriteStream('result.json'),
    indent: 4
}

writer.writeJson(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    dest: {},
    indent: 4
}

writer.writeJson(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```
<a name="Writer+writeJs"></a>
### writer.writeJs(json, options) ⇒ <code>Promise</code>
Writes a JSON object to a _*.js_ file. The object is prefixed by `module.exports = `.

**Kind**: instance method of <code>[Writer](#Writer)</code>  
**Returns**: <code>Promise</code> - - Containing the write success message to handle by caller (e.g. for logging).  
**Access:** public  
**See**

- [MIN_INDENT](#Constants+MIN_INDENT)
- [DEFAULT_INDENT](#Constants+DEFAULT_INDENT)
- [MAX_INDENT](#Constants+MAX_INDENT)


| Param | Type | Description |
| --- | --- | --- |
| json | <code>object</code> | The JSON to write into _*.js_ file. |
| options | <code>[Options](#Options)</code> | The write destination and indention. |

**Example**  
```js
var Writer = require('jy-transform').Writer;
var logger = ...;
var writer = new Writer(logger);

var json = {...};
var options = {
    dest: 'result.js',
    indent: 2
}

writer.writeJs(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    dest: fs.createWriteStream('result.json'),
    indent: 4
}

writer.writeJs(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });

options = {
    dest: {},
    indent: 2
}

writer.writeJs(json, options)
    .then(function (msg){
        logger.info(msg);
    })
    .catch(function (err) {
        logger.error(err.stack);
    });
```
<a name="Options"></a>
## Options : <code>object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| origin | <code>string</code> | <code>&quot;yaml&quot;</code> | The origin type. |
| target | <code>string</code> | <code>&quot;js&quot;</code> | The target type. |
| src | <code>string</code> &#124; <code>Readable</code> &#124; <code>object</code> |  | The source. |
| dest | <code>string</code> &#124; <code>Writable</code> &#124; <code>object</code> |  | The destination. |
| indent | <code>number</code> | <code>4</code> | The indention in files. |
| exports | <code>string</code> |  | The exports name for usage in JS files only. |

