<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>jy-transform by deadratfink</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">jy-transform</h1>
      <h2 class="project-tagline">This project aims to read, write and transform YAML, JS or JSON objects into each other using CLI or API. The source and destination resources can be files, objects or streams.</h2>
      <a href="https://github.com/deadratfink/jy-transform" class="btn">View on GitHub</a>
      <a href="https://github.com/deadratfink/jy-transform/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/deadratfink/jy-transform/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><img src="https://github.com/deadratfink/jy-transform/blob/master/image/jytransform.png" alt="jy-transform logo"></p>

<h1>
<a id="stats" class="anchor" href="#stats" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stats</h1>

<table>
<thead>
<tr>
<th><a href="https://github.com/deadratfink/jy-transform/blob/master/LICENSE.md">Github License</a></th>
<th><a href="https://github.com/deadratfink/jy-transform/issues">Github Issues</a></th>
<th><a href="https://github.com/deadratfink/jy-transform/releases">Github Release</a></th>
<th><a href="https://github.com/deadratfink/jy-transform/tags">Github Tags</a></th>
<th><a href="https://travis-ci.org">Travis CI</a></th>
<th><a href="https://waffle.io/deadratfink/jy-transform">Waffle</a></th>
<th><a href="https://codeclimate.com/github/deadratfink/jy-transform">Code Climate</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/deadratfink/jy-transform/blob/master/LICENSE.md"><img src="https://img.shields.io/github/license/deadratfink/jy-transform.svg?style=flat-square" alt="License"></a></td>
<td><a href="https://github.com/deadratfink/jy-transform/issues"><img src="https://img.shields.io/github/issues/deadratfink/jy-transform.svg?style=flat-square" alt="Issue Stats"></a></td>
<td><a href="https://github.com/deadratfink/jy-transform/releases"><img src="https://img.shields.io/github/release/deadratfink/jy-transform.svg?style=flat-square" alt="Github Releases"></a></td>
<td><a href="https://github.com/deadratfink/jy-transform/tags"><img src="https://img.shields.io/github/tag/deadratfink/jy-transform.svg?style=flat-square" alt="Github Tags"></a></td>
<td><a href="https://travis-ci.org/deadratfink/jy-transform/branches"><img src="https://img.shields.io/travis/deadratfink/jy-transform.svg?style=flat-square" alt="Build Status"></a></td>
<td><a href="https://waffle.io/deadratfink/jy-transform"><img src="https://badge.waffle.io/deadratfink/jy-transform.png?label=ready&amp;title=Ready&amp;style=flat-square" alt="Waffle"></a></td>
<td><a href="https://codeclimate.com/github/deadratfink/jy-transform"><img src="https://img.shields.io/codeclimate/github/deadratfink/jy-transform.svg?style=flat-square" alt="Code Climate"></a></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Branch</th>
<th><a href="https://codecov.io">Codecov</a></th>
<th><a href="https://coveralls.io">Coveralls</a></th>
<th><a href="http://inch-ci.org">Inch CI</a></th>
<th>
<a href="https://david-dm.org">David</a> DM</th>
<th>
<a href="https://david-dm.org">David</a> DM (dev)</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td><a href="https://codecov.io/github/deadratfink/jy-transform?branch=master"><img src="https://img.shields.io/codecov/c/github/deadratfink/jy-transform/master.svg?style=flat-square" alt="codecov.io"></a></td>
<td><a href="https://coveralls.io/github/deadratfink/jy-transform?branch=master"><img src="https://img.shields.io/coveralls/deadratfink/jy-transform/master.svg?style=flat-square" alt="coveralls.io"></a></td>
<td><a href="https://inch-ci.org/github/deadratfink/jy-transform?branch=master"><img src="https://inch-ci.org/github/deadratfink/jy-transform.svg?branch=master&amp;style=flat-square" alt="inch-ci.org"></a></td>
<td><a href="https://david-dm.org/deadratfink/jy-transform/master"><img src="https://img.shields.io/david/deadratfink/jy-transform/master.svg?style=flat-square" alt="Dependency Status"></a></td>
<td><a href="https://david-dm.org/deadratfink/jy-transform/master#info=devDependencies"><img src="https://img.shields.io/david/dev/deadratfink/jy-transform/master.svg?style=flat-square" alt="devDependency Status"></a></td>
</tr>
<tr>
<td>development</td>
<td><a href="https://codecov.io/github/deadratfink/jy-transform?branch=development"><img src="https://img.shields.io/codecov/c/github/deadratfink/jy-transform/development.svg?style=flat-square" alt="codecov.io"></a></td>
<td><a href="https://coveralls.io/github/deadratfink/jy-transform?branch=development"><img src="https://img.shields.io/coveralls/deadratfink/jy-transform/development.svg?style=flat-square" alt="coveralls.io"></a></td>
<td><a href="https://inch-ci.org/github/deadratfink/jy-transform?branch=development"><img src="https://inch-ci.org/github/deadratfink/jy-transform.svg?branch=development&amp;style=flat-square" alt="inch-ci.org"></a></td>
<td><a href="https://david-dm.org/deadratfink/jy-transform/development"><img src="https://img.shields.io/david/deadratfink/jy-transform/development.svg?style=flat-square" alt="Dependency Status"></a></td>
<td><a href="https://david-dm.org/deadratfink/jy-transform/development#info=devDependencies"><img src="https://img.shields.io/david/dev/deadratfink/jy-transform/development.svg?style=flat-square" alt="devDependency Status"></a></td>
</tr>
</tbody>
</table>

<h2>
<a id="coverage-graphs" class="anchor" href="#coverage-graphs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Coverage Graphs</h2>

<table>
<thead>
<tr>
<th>Branch</th>
<th>Graph</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td><img src="https://codecov.io/github/deadratfink/jy-transform/branch.svg?branch=master&amp;vg=true" alt="codecov.io"></td>
</tr>
<tr>
<td>development</td>
<td><img src="https://codecov.io/github/deadratfink/jy-transform/branch.svg?branch=development&amp;vg=true" alt="codecov.io"></td>
</tr>
</tbody>
</table>





<h1>
<a id="toc" class="anchor" href="#toc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TOC</h1>

<ul>
<li>
<a href="#jy-transform">jy-transform</a>

<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#dev-dependencies">Dev Dependencies</a></li>
<li><a href="#license">License</a></li>
<li><a href="#motivation">Motivation</a></li>
</ul>
</li>
<li>
<a href="#usage">Usage</a>

<ul>
<li><a href="#usage-types">Usage Types</a></li>
<li><a href="#use-cases">Use Cases</a></li>
<li><a href="#limitations">Limitations</a></li>
<li><a href="#cli-usage">CLI Usage</a></li>
<li><a href="#origin-and-target-type-inference">Origin and Target Type Inference</a></li>
<li><a href="#api-usage">API Usage</a></li>
<li><a href="#using-custom-logger">Using Custom Logger</a></li>
</ul>
</li>
<li><a href="#api-reference">API Reference</a></li>
<li><a href="#changelog">Changelog</a></li>
<li><a href="#contributing">Contributing</a></li>
</ul>



<h1>
<a id="jy-transform" class="anchor" href="#jy-transform" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>jy-transform</h1>

<p>This project aims to read, write and transform YAML, JS or JSON objects into each other using CLI or API. The source and destination resources can be files on CLI and additionally, objects or streams on API level. Besides the transformation feature this module can also be used for simple loading and/or writing YAML, JS or JSON files.</p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h2>

<p>Download node at <a href="http://nodejs.org">nodejs.org</a> and install it, if you haven't already.</p>

<div class="highlight highlight-source-shell"><pre>npm install jy-transform --global</pre></div>

<h2>
<a id="tests" class="anchor" href="#tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tests</h2>

<div class="highlight highlight-source-shell"><pre>npm install
npm <span class="pl-c1">test</span></pre></div>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependencies</h2>

<ul>
<li>
<a href="https://github.com/petkaantonov/bluebird">bluebird</a>: Full featured Promises/A+ implementation with exceptionally good performance</li>
<li>
<a href="https://github.com/chriso/cli">cli</a>: A tool for rapidly building command line apps</li>
<li>
<a href="https://github.com/sindresorhus/is-stream">is-stream</a>: Check if something is a Node.js stream</li>
<li>
<a href="https://github.com/nodeca/js-yaml">js-yaml</a>: YAML 1.2 parser and serializer</li>
<li>
<a href="https://github.com/isaacs/json-stringify-safe">json-stringify-safe</a>: Like JSON.stringify, but doesn't blow up on circular refs.</li>
<li>
<a href="https://github.com/fs-utils/mkdirp-then">mkdirp-then</a>: mkdirp as promised</li>
<li>
<a href="https://github.com/RReverser/serialize-js">serialize-js</a>: User-readable object serialization for JavaScript.</li>
</ul>

<h2>
<a id="dev-dependencies" class="anchor" href="#dev-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dev Dependencies</h2>

<ul>
<li>
<a href="https://github.com/codeclimate/javascript-test-reporter">codeclimate-test-reporter</a>: Code Climate test reporter client for javascript projects</li>
<li>
<a href="https://github.com/codecov/codecov-node">codecov</a>: Uploading report to Codecov: <a href="https://codecov.io">https://codecov.io</a>
</li>
<li>
<a href="https://github.com/nickmerwin/node-coveralls">coveralls</a>: takes json-cov output into stdin and POSTs to coveralls.io</li>
<li>
<a href="https://github.com/thlorenz/doctoc">doctoc</a>: Generates TOC for markdown files of local git repo.</li>
<li>
<a href="https://github.com/jprichardson/node-fs-extra">fs-extra</a>: fs-extra contains methods that aren't included in the vanilla Node.js fs package. Such as mkdir -p, cp -r, and rm -rf.</li>
<li>
<a href="https://github.com/gotwarlost/istanbul">istanbul</a>: Yet another JS code coverage tool that computes statement, line, function and branch coverage with module loader hooks to transparently add coverage when running tests. Supports all JS coverage use cases including unit tests, server side functional tests </li>
<li>
<a href="https://github.com/jsdoc2md/jsdoc-parse">jsdoc-parse</a>: Jsdoc-annotated source code in, JSON format documentation out.</li>
<li>
<a href="https://github.com/jsdoc2md/jsdoc-to-markdown">jsdoc-to-markdown</a>: jsdoc-annotated source in, markdown API docs out.</li>
<li>
<a href="https://github.com/mochajs/mocha">mocha</a>: simple, flexible, fun test framework</li>
<li>
<a href="https://github.com/StevenLooman/mocha-lcov-reporter">mocha-lcov-reporter</a>: LCOV reporter for Mocha</li>
<li>
<a href="https://github.com/mariocasciaro/object-path">object-path</a>: Access deep properties using a path</li>
<li>
<a href="https://github.com/zeke/package-json-to-readme">package-json-to-readme</a>: Generate a README.md from package.json contents</li>
<li>
<a href="https://github.com/winstonjs/winston">winston</a>: A multi-transport async logging library for Node.js</li>
</ul>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<p>SEE LICENSE IN <a href="https://github.com/deadratfink/jy-transform/blob/master/LICENSE.md">LICENSE.md</a></p>

<h2>
<a id="motivation" class="anchor" href="#motivation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Motivation</h2>

<p>Why this module? After struggling with some huge YAML file and accidentally 
occurring wrong indentions which results in an annoying failure investigation, 
I decided to get rid of the YAML file and therefore, create a module which 
should be aimed as the swiss army knife for transforming YAML, JS and JSON 
types into each other format.</p>

<h1>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h1>

<p>The module can be used on CLI or as API (the latter is fully <a href="http://bluebirdjs.com/docs/api-reference.html">Promise</a> 
based).</p>

<h2>
<a id="usage-types" class="anchor" href="#usage-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage Types</h2>

<p>Since the module can be used in two different ways, use installation as follows:</p>

<ul>
<li>CLI: install globally via <code>-g</code> option</li>
<li>API: install locally</li>
</ul>

<p>Both usage types are described in more detail in the following sections.</p>

<h2>
<a id="use-cases" class="anchor" href="#use-cases" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use Cases</h2>

<p>So, what are the typical use cases for this module? In terms of <em>transformation</em>
these consists of different phases:</p>

<ul>
<li>Reading files (<code>Reader</code>)</li>
<li>Transforming JSON objects (<code>Transformer</code>)</li>
<li>Apply dedicated actions on the intermediate JSON objects (<code>Transformer</code> + <code>Middleware</code>)</li>
<li>Writing files (<code>Writer</code>)</li>
</ul>

<h3>
<a id="reading" class="anchor" href="#reading" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reading</h3>

<p>Reading from:</p>

<ul>
<li>
<em>*.yaml</em> file</li>
<li>
<em>*.js</em> file</li>
<li>
<em>*.json</em> file</li>
</ul>

<p>Additionally, on API level:</p>

<ul>
<li>
<code>stream.Readable</code> (requires <code>options.origin</code> property set, reads as UTF-8)</li>
<li>any JS <code>object</code> (actually, this means the reading phase is skipped, because object is in-memory already)</li>
</ul>

<h3>
<a id="transformation" class="anchor" href="#transformation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Transformation</h3>

<p>The transformation can take place into several directions:</p>

<ul>
<li>YAML =&gt; JS</li>
<li>YAML =&gt; JSON</li>
<li>JS   =&gt; YAML</li>
<li>JSON =&gt; YAML </li>
<li>JS   =&gt; JSON </li>
<li>JSON =&gt; JS </li>
<li>YAML =&gt; YAML<br>
</li>
<li>JSON =&gt; JSON</li>
<li>JS   =&gt; JS<br>
</li>
</ul>

<p>while:</p>

<ul>
<li>
<a href="http://http://yaml.org/">YAML</a> = <em>*.yaml</em>, <em>*.yml</em>
</li>
<li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">JS</a> = <em>*.js</em>   (JS object)<br>
</li>
<li>
<a href="http://json.org">JSON</a> = <em>*.json</em> (JS object serialized as JSON)</li>
</ul>

<h3>
<a id="middleware" class="anchor" href="#middleware" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Middleware</h3>

<p>Apply actions on the intermediate JS object via injected <a href="http://bluebirdjs.com/docs/api-reference.html">Promise</a> 
functions. This is an optional part for <a href="#transformation">transformation</a> phase.</p>

<h3>
<a id="writing" class="anchor" href="#writing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writing</h3>

<p>Writing to:</p>

<ul>
<li>
<em>*.yaml</em> file</li>
<li>
<em>*.js</em> file</li>
<li>
<em>*.json</em> file</li>
</ul>

<p>Additionally, on API level:</p>

<ul>
<li>
<code>stream.Writable</code>  (requires <code>options.target</code> property set, writes UTF-8)</li>
<li>any JS <code>object</code>
</li>
</ul>

<h2>
<a id="limitations" class="anchor" href="#limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limitations</h2>

<ul>
<li>Since this module is build to transform from and to different type formats, any 
<code>Function</code>s residing in JS type objects are <em>not</em> supported, e.g. transforming
<code>javascript
module.exports = {
    fooKey: 'foo',
    fooFunction: foo() {...}
}
</code>
to JSON would simply result in 
<code>javascript
{
    fooKey: 'foo'
}
</code>
while transforming to YAML type would even result in an <code>Error</code>, e.g. printed 
on CLI usage like this:
<code>
ERROR: YAMLException: unacceptable kind of an object to dump [object Function]
</code>
</li>
<li>Multidocument handling would be a cool feature which refers in general to YAML 
and JS only, but at the moment we require that each document to transform is a 
<em>single</em> one per source (or in case of JS could be identified)! This feature is 
planned and reflected in <a href="https://github.com/deadratfink/jy-transform/issues/14">#14</a>.</li>
<li>Schema validation for input and output is another topic which is planned by 
<a href="https://github.com/deadratfink/jy-transform/issues/1">#1</a> and 
<a href="https://github.com/deadratfink/jy-transform/issues/2">#2</a>.</li>
</ul>

<h2>
<a id="cli-usage" class="anchor" href="#cli-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CLI Usage</h2>

<p>The CLI provides the <code>jyt</code> command (actually, this requires the use of options). 
After the global installation you can access the <code>Transformer</code> command options 
with the usual help command as follows:</p>

<pre><code>$ jyt --help
</code></pre>

<h3>
<a id="cli-options" class="anchor" href="#cli-options" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CLI Options</h3>

<p>The <code>--help</code> option prints an overview about all available CLI properties:</p>

<pre><code>$ jyt --help
Usage:
  jyt [OPTIONS]

Options: 
  -o, --origin [STRING]  The conversion origin: [ js | json | yaml ]. (Default is : if not given, the type is tried to be inferred from the extension of source path, else it is yaml)
  -t, --target [STRING]  The conversion target: [ js | json | yaml ]. (Default is : if not given, the type is tried to be inferred from the extension of destination path, else it is js)
  -s, --src PATH         The absolute/relative input file path.
  -d, --dest [PATH]      The absolute/relative output file path. When this 
                         options is ommited then the output file is stored 
                         relative to the input file (same base name but with 
                         another extension if type differs). If input and 
                         output type are the same then the file overwriting is 
                         handled depending on the '--force' value!  (Default is storing relative to input file)
  -i, --indent [NUMBER]  The indention for pretty-print: 1 - 8.  (Default is 4)
  -f, --force            Force overwriting of existing output files on write 
                         phase. When files are not overwritten (which is 
                         default), then the next transformation with same 
                         output file name gets a consecutive number on the base 
                         file name, e.g. in case of foo.yaml it would be 
                         foo(1).yaml.
  -m, --imports STRING   Define a 'module.exports[.identifier] = ' 
                         identifier (to read from JS _source_ file only, must 
                         be a valid JS identifier!).                          
  -x, --exports STRING   Define a 'module.exports[.identifier] = ' 
                         identifier, for usage in JS destination file only, 
                         must be a valid JS identifier! 
  -k, --no-color         Omit color from output
      --debug            Show debug information
  -v, --version          Display the current version
  -h, --help             Display help and usage details
</code></pre>

<p>These are more formally defined in the following table: </p>

<table>
<thead>
<tr>
<th>Option (short)</th>
<th>Option (long)</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o</code></td>
<td><code>--origin</code></td>
<td>[ <em>js</em> | <em>json</em> | <em>yaml</em> ]</td>
<td>The transformation origin type.</td>
<td>if not given, the type is tried to be inferred from the extension of source path, else it is <em>yaml</em>
</td>
<td>no</td>
</tr>
<tr>
<td><code>-t</code></td>
<td><code>--target</code></td>
<td>[ <em>js</em> | <em>json</em> | <em>yaml</em> ]</td>
<td>The transformation target type.</td>
<td>if not given, the type is tried to be inferred from the extension of destination path, else it is <em>js</em>
</td>
<td>no</td>
</tr>
<tr>
<td><code>-s</code></td>
<td><code>--src</code></td>
<td>URI</td>
<td>The source file path for transformation.</td>
<td>-</td>
<td>yes</td>
</tr>
<tr>
<td><code>-d</code></td>
<td><code>--dest</code></td>
<td>URI</td>
<td>The destination file path to transform to.</td>
<td>When this options is ommited then the output file is stored relative to the input file (same base name but with another extension if type differs). If input and output type are the same then the file overwriting is handled depending on the <code>--force</code> value!</td>
<td>no</td>
</tr>
<tr>
<td><code>-i</code></td>
<td><code>--indent</code></td>
<td>integer<br> - [ 1 - 8 ]<br>
</td>
<td>The code indention used in destination files.</td>
<td>4</td>
<td>no</td>
</tr>
<tr>
<td><code>-f</code></td>
<td><code>--force</code></td>
<td>n/a</td>
<td>Force overwriting of existing output files on write phase. When files are not overwritten (which is default), then the next transformation with same output file name gets a consecutive number on the base file name, e.g. in case of foo.yaml it would be foo(1).yaml.</td>
<td><em>false</em></td>
<td>no</td>
</tr>
<tr>
<td><code>-m</code></td>
<td><code>--imports</code></td>
<td>string</td>
<td>Define a 'module.exports[.identifier] = ' identifier (to read from JS <em>source</em> file only, must be a valid JS identifier!)</td>
<td><em>undefined</em></td>
<td>no</td>
</tr>
<tr>
<td><code>-x</code></td>
<td><code>--exports</code></td>
<td>string</td>
<td>Define a 'module.exports[.identifier] = ' identifier (for usage in JS <em>destination</em> file only, must be a valid JS identifier!)</td>
<td><em>undefined</em></td>
<td>no</td>
</tr>
<tr>
<td><code>-k</code></td>
<td><code>--no-color</code></td>
<td>n/a</td>
<td>Omit color from output.</td>
<td><em>color</em></td>
<td>no</td>
</tr>
<tr>
<td>n/a</td>
<td><code>--debug</code></td>
<td>n/a</td>
<td>Show debug information.</td>
<td><em>false</em></td>
<td>no</td>
</tr>
<tr>
<td><code>-v</code></td>
<td><code>--version</code></td>
<td>n/a</td>
<td>Display the current version.</td>
<td>n/a</td>
<td>no</td>
</tr>
<tr>
<td><code>-h</code></td>
<td><code>--help</code></td>
<td>n/a</td>
<td>Display help and usage details.</td>
<td>n/a</td>
<td>no</td>
</tr>
</tbody>
</table>

<p><strong>NOTE:</strong> an invalid indention setting (1 &gt; <code>-i</code>, <code>--indent</code> &gt; 8) does not raise an error but a default of 4 SPACEs is applied instead.</p>

<h3>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h3>

<p>Now we know which properties we can apply on CLI, so let's assume we 
have a YAML file located in <em>foo.yaml</em> holding this data:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">foo:</span> <span class="pl-s">bar</span></span></pre></div>

<h4>
<a id="example-yaml--json" class="anchor" href="#example-yaml--json" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: YAML =&gt; JSON</h4>

<p>then we can transform it to a JSON file <em>foo.json</em></p>

<div class="highlight highlight-source-js"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>
}</pre></div>

<p>using this command:</p>

<pre><code>$ jyt -s foo.yaml -t json -i 2
</code></pre>

<p>In this example we have overwritten the standard target type (which is <code>js</code>) 
and applying an indent of <em>2</em> instead of the default <em>4</em>. As default the output 
file <em>foo.json</em> is written relative to the input file (simply omitting the 
<code>dest</code> option here).</p>

<p><strong>NOTE:</strong> here you <em>have</em> to provide the target with <code>-t json</code> or else the 
default <code>js</code> would have been applied! If the source would have been a <code>js</code> 
type like</p>

<pre><code>$ jyt -s foo.js -t json -i 2
</code></pre>

<p>then the <code>js</code> value for <code>origin</code> is automatically inferred from file extension. 
Accordingly, this is also true for the <code>target</code> option.</p>

<h4>
<a id="example-json--js" class="anchor" href="#example-json--js" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: JSON =&gt; JS</h4>

<pre><code>$ jyt -s foo.json -i 2
</code></pre>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> {
  foo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>
}</pre></div>

<h4>
<a id="example-js--yaml" class="anchor" href="#example-js--yaml" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: JS =&gt; YAML</h4>

<pre><code>$ jyt -s foo.js -t yaml
</code></pre>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">foo:</span> <span class="pl-s">bar</span></span></pre></div>

<h4>
<a id="example-transformation-with-different-destination" class="anchor" href="#example-transformation-with-different-destination" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: Transformation with Different Destination</h4>

<p>Simply provide the <code>-d</code> with a different file name:</p>

<pre><code>$ jyt -s foo.json -d results/foobar.yaml
</code></pre>

<h4>
<a id="example-transformation-with-unsupported-source-file-extension" class="anchor" href="#example-transformation-with-unsupported-source-file-extension" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: Transformation with Unsupported Source File Extension</h4>

<p>As said, normally we infer from file extension to the type but assume the source 
file has a file name which does not imply the type (here JS 
type in a TEXT file), then you can simply provide the <code>-o</code> option with the 
correct <code>origin</code> type (of course, the <code>-t</code> option works analogous):</p>

<pre><code>$ jyt -s foo.txt -o js -d foobar.yaml
</code></pre>

<h4>
<a id="example-read-from-file-with-exports-identifier" class="anchor" href="#example-read-from-file-with-exports-identifier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: Read from File with Exports Identifier</h4>

<p>It could be that a JS source <code>exports</code> several objects and you want to read 
from exactly the one you specify, then provide the <code>-m</code> (<code>--imports</code>) option.</p>

<p>In this this example we have a <em>foo.js</em> file exporting <em>two</em> objects:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">module</span>.<span class="pl-smi">exports</span>.<span class="pl-smi">foo</span> <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bar<span class="pl-pds">'</span></span>
};

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span>.<span class="pl-smi">bar</span> <span class="pl-k">=</span> {
    bar<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>
};</pre></div>

<p>but you want to convert <code>bar</code> object, then call:</p>

<pre><code>$ jyt -s foo.js -m bar -d bar.yaml
</code></pre>

<p>to get the YAML result:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">bar:</span> <span class="pl-s">foo</span></span></pre></div>

<p><strong>NOTE:</strong> the same applies on API level when using JS objects as <code>dest</code>:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> fooBar <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bar<span class="pl-pds">'</span></span>,
    bar<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>
};

<span class="pl-k">var</span> options <span class="pl-k">=</span> {
    src<span class="pl-k">:</span> fooBar,
    dest<span class="pl-k">:</span> {},
    exports<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bar<span class="pl-pds">'</span></span>
};

<span class="pl-c">//...transform</span></pre></div>

<p>The transformation will result in this in-memory object:</p>

<div class="highlight highlight-source-js"><pre>bar<span class="pl-k">:</span> {
    foo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>bar<span class="pl-pds">'</span></span>,
    bar<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>foo<span class="pl-pds">'</span></span>
}</pre></div>

<p>as sub-node of <code>options.dest</code>.</p>

<h4>
<a id="example-write-exports-identifier-for-js-file" class="anchor" href="#example-write-exports-identifier-for-js-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: Write Exports Identifier for JS File</h4>

<p>Assume you want to generate a JS file with an exports string which gets an 
identifier. We reuse the YAML file from above </p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">foo:</span> <span class="pl-s">bar</span></span></pre></div>

<p>using this command:</p>

<pre><code>$ jyt -s foo.yaml -d foobar.js -x foobar
</code></pre>

<p>This generates the following output in JS file using <code>foobar</code> as identifier:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c1">module</span>.<span class="pl-smi">exports</span>.<span class="pl-smi">foobar</span> <span class="pl-k">=</span> {
    foo<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>
}</pre></div>

<p><strong>NOTE:</strong> the identifier must be a valid JS identifier accoding to ECMAScript 6
(see also <a href="https://mathiasbynens.be/notes/javascript-identifiers-es6">Valid JavaScript variable names in ECMAScript 6</a> 
and <a href="https://mathiasbynens.be/demo/javascript-identifier-regex">Generating a regular expression to match valid JavaScript identifiers</a>).</p>

<h4>
<a id="example-force-overwriting" class="anchor" href="#example-force-overwriting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example: Force Overwriting</h4>

<p><strong>IMPORTANT NOTE:</strong> when using this feature then any subsequent 
execution which uses the same target/file name, 
will overwrite the original source or target created beforehand!</p>

<p>By default this feature is not enabled to prevent you from accidentally 
overwriting your input source or already generated targets.</p>

<p>But let's say we want to overwrite the original source now because you want 
to change the indention from 2 to 4 SPACEs, then we can do this as follows:</p>

<pre><code>$ jyt -s foo.js -f
</code></pre>

<p>Of course, leaving out the <code>-f</code> switch creates a new file relatively to 
the <code>origin</code>, named as <em>foo(1).js</em> (note the consecutive number). Naturally, 
another run of the command would result int a file called <em>foo(2).js</em> 
and so forth.</p>

<h2>
<a id="origin-and-target-type-inference" class="anchor" href="#origin-and-target-type-inference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Origin and Target Type Inference</h2>

<p>The examples above have shown that we have an automatic type inference from file 
extensions. This is supported as shown by the following table (from-to):</p>

<table>
<thead>
<tr>
<th>File Extension</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>*.yaml</em></td>
<td><em>yaml</em></td>
</tr>
<tr>
<td><em>*.yml</em></td>
<td><em>yaml</em></td>
</tr>
<tr>
<td><em>*.js</em></td>
<td><em>js</em></td>
</tr>
<tr>
<td><em>*.json</em></td>
<td><em>json</em></td>
</tr>
</tbody>
</table>

<p><strong>NOTE:</strong> if you have files without an extension or e.g. <em>*.txt</em> you <em>have</em> to 
specify the origin or target type!</p>

<h2>
<a id="api-usage" class="anchor" href="#api-usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Usage</h2>

<p>Since the usage on CLI is a 2-step process:</p>

<ol>
<li>Read from source file to JS object =&gt; </li>
<li>Write out (maybe to other type)</li>
</ol>

<p>the direct API calls additionally provide the usage of a <em>middleware</em> function 
where you can alter the input JS object before it is written and therefore, which turns 
this into a 3-step process:</p>

<ol>
<li>Read from source =&gt; </li>
<li>Alter the JS object =&gt; </li>
<li>Write out (maybe to other type)</li>
</ol>

<p>For more details about this and all the functions provided by this module please refer to the 
<a href="https://github.com/deadratfink/jy-transform/wiki/API-v1.0">API Reference</a>.</p>

<p>The <code>origin</code> and <code>target</code> type inference is also standard for the API level.</p>

<h3>
<a id="api-properties" class="anchor" href="#api-properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Properties</h3>

<p>The <code>Transformer</code> exposes the following function which takes besides an (optional) 
<code>middleware</code> function the necessary <code>options</code> for the transformation:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">transform</span>(<span class="pl-smi">options</span>, <span class="pl-smi">middleware</span>)</pre></div>

<p>The <code>options</code> object has to follow this key-values table:</p>

<table>
<thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr>
<td>origin</td>
<td><code>string</code></td>
<td>The origin type.</td>
<td>If not given, the type is tried to be inferred from the extension of source path, else it is <em>yaml</em>.</td>
<td>no</td>
</tr>
<tr>
<td>target</td>
<td><code>string</code></td>
<td>The target type.</td>
<td>If not given, the type is tried to be inferred from the extension of destination path, else it is <em>js</em>
</td>
<td>no</td>
</tr>
<tr>
<td>src</td>
<td><code>string | Readable | object</code></td>
<td>The source information object: <code>string</code> is used as file path, <code>Readable</code> stream provides a stringified source and <code>object</code> is used as direct JS source.</td>
<td>-</td>
<td>yes</td>
</tr>
<tr>
<td>dest</td>
<td><code>string | Writable | object</code></td>
<td>The destination information object: <code>string</code> is used as file path, <code>Writable</code> stream writes a stringified source and <code>object</code> is used as direct JS object for assignment.</td>
<td>The output file is stored relative to the input file (same base name but with another extension if type differs). If input and output type are the same then the file overwriting is handled depending on the 'force' value!</td>
<td>no</td>
</tr>
<tr>
<td>indent</td>
<td><code>number</code></td>
<td>The indention in files.</td>
<td>4</td>
<td>no</td>
</tr>
<tr>
<td>force</td>
<td><code>boolean</code></td>
<td>Force overwriting of existing output files on write phase. When files are not overwritten, then the next transformation with same output file name gets a consecutive number on the base file name, e.g. in case of <em>foo.yaml</em> it would be <em>foo(1).yaml</em>.</td>
<td><em>false</em></td>
<td>no</td>
</tr>
<tr>
<td>imports</td>
<td><code>string</code></td>
<td>Define a 'module.exports[.identifier] = ' identifier (to read from JS <em>source</em> only, must be a valid JS identifier!)</td>
<td><em>undefined</em></td>
<td>no</td>
</tr>
<tr>
<td>exports</td>
<td><code>string</code></td>
<td>Define a 'module.exports[.identifier] = ' identifier (for usage in JS <em>destination</em> only, must be a valid JS identifier!)</td>
<td><em>undefined</em></td>
<td>no</td>
</tr>
</tbody>
</table>

<p><strong>NOTE:</strong> an invalid indention setting (1 &gt; indent &gt; 8) does not raise an error but a default of 4 SPACEs is applied instead.</p>

<h4>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example</h4>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> options <span class="pl-k">=</span> {
    origin<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>json<span class="pl-pds">'</span></span>,
    target<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>yaml<span class="pl-pds">'</span></span>,
    src<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>foo.json<span class="pl-pds">'</span></span>,
    dest<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>./foo/bar.yaml<span class="pl-pds">'</span></span>,
    indent<span class="pl-k">:</span> <span class="pl-c1">2</span>
}</pre></div>

<h3>
<a id="using-middleware" class="anchor" href="#using-middleware" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Middleware</h3>

<p>The <code>middleware</code> is optional but if provided it must be of type <code>Function</code> and 
a <a href="http://bluebirdjs.com/docs/api-reference.html">Promise</a>. One of the easiest 
ones is the identity function </p>

<p><em>f(data) -&gt; data</em> </p>

<p>which could be expressed as 
<a href="http://bluebirdjs.com/docs/api-reference.html">Promise</a> function as follows:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">identity</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">data</span>) {
    <span class="pl-k">return</span> <span class="pl-smi">Promise</span>.<span class="pl-en">resolve</span>(data);
}</pre></div>

<p>Of course, this would have no effect on the provided JS data. Actually, this one is 
used internally when no middleware is provided to ensure the proper promised 
control flow.</p>

<p>OK, lets go back to a more practical example, e.g. we want to alter the value of
JS property before it is written to a file. Assuming we have this piece of YAML
object as input:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">foo:</span> <span class="pl-s">old bar</span></span></pre></div>

<p>Applying this <a href="http://bluebirdjs.com/docs/api-reference.html">Promise</a> as middleware</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">middleware</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">data</span>) {
    <span class="pl-smi">data</span>.<span class="pl-smi">foo</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>new bar<span class="pl-pds">'</span></span>; 
    <span class="pl-k">return</span> <span class="pl-smi">Promise</span>.<span class="pl-en">resolve</span>(data);
}

<span class="pl-smi">transformer</span>.<span class="pl-en">transform</span>(options, middleware)
    .<span class="pl-en">then</span>(<span class="pl-k">function</span> (<span class="pl-smi">msg</span>){
        <span class="pl-smi">logger</span>.<span class="pl-en">info</span>(msg);
    })
    .<span class="pl-en">catch</span>(<span class="pl-k">function</span> (<span class="pl-smi">err</span>) {
        <span class="pl-smi">logger</span>.<span class="pl-en">error</span>(<span class="pl-smi">err</span>.<span class="pl-smi">stack</span>);
    });</pre></div>

<p>will result in such JSON file:</p>

<div class="highlight highlight-source-js"><pre>{
    <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>new bar<span class="pl-pds">"</span></span>
}</pre></div>

<p>Of course, in real world scenarios you will have use cases which usually have a 
higher complexity where one function might be insufficient or at least 
inconvenient. but this does not raise a problem at all, because you can create 
several functions to be applied in the whole transformation process by gathering 
them in one function.</p>

<p>Let's assume we have some Promise functions to apply. For simplicity reasons we 
simulate these for the moment by two functions, each adding a key-value to the 
given (initially empty) JS object.</p>

<p><strong>NOTE:</strong> each of them has to resolve with the <code>data</code> object! </p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">key1</span>(<span class="pl-smi">data</span>) {
    <span class="pl-smi">objectPath</span>.<span class="pl-en">set</span>(data, <span class="pl-s"><span class="pl-pds">'</span>key1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>value1<span class="pl-pds">'</span></span>);
    <span class="pl-k">return</span> <span class="pl-smi">Promise</span>.<span class="pl-en">resolve</span>(data);
}

<span class="pl-k">function</span> <span class="pl-en">key2</span>(<span class="pl-smi">data</span>) {
    <span class="pl-smi">objectPath</span>.<span class="pl-en">set</span>(data, <span class="pl-s"><span class="pl-pds">'</span>key2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>value2<span class="pl-pds">'</span></span>);
    <span class="pl-k">return</span> <span class="pl-smi">Promise</span>.<span class="pl-en">resolve</span>(data);
}</pre></div>

<p>These can be collected by different aggregation or composition functions of the underlying
Promise framework, e.g. using the  <a href="http://bluebirdjs.com/docs/api/promise.all.html"><code>Promise.all([...])</code></a> 
function. This one can collect all three functions above and ensure their proper subsequent execution:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-en">middleware</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">data</span>) {
    <span class="pl-k">return</span> <span class="pl-smi">Promise</span>.<span class="pl-c1">all</span>([<span class="pl-en">key1</span>(data), <span class="pl-en">key2</span>(data)])
        .<span class="pl-en">then</span>(<span class="pl-k">function</span>(<span class="pl-smi">result</span>) {
            <span class="pl-k">return</span> <span class="pl-smi">Promise</span>.<span class="pl-en">resolve</span>(result[<span class="pl-smi">result</span>.<span class="pl-c1">length</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>]);
        });
};

<span class="pl-k">var</span> transformer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Transformer</span>(logger);
<span class="pl-k">var</span> logger <span class="pl-k">=</span> <span class="pl-k">...</span>;
<span class="pl-k">var</span> options <span class="pl-k">=</span> {<span class="pl-k">...</span>};

<span class="pl-k">return</span> <span class="pl-smi">transformer</span>.<span class="pl-en">transform</span>(options, middleware)
    .<span class="pl-en">then</span>(<span class="pl-k">function</span> (<span class="pl-smi">msg</span>){
        <span class="pl-smi">logger</span>.<span class="pl-en">info</span>(msg);
    })
    .<span class="pl-en">catch</span>(<span class="pl-k">function</span> (<span class="pl-smi">err</span>) {
        <span class="pl-smi">logger</span>.<span class="pl-en">error</span>(<span class="pl-smi">err</span>.<span class="pl-smi">stack</span>);
    });</pre></div>

<p>Then the result in the <code>middleware</code> function can be retrieved from the returned 
array, i.e. in case of <a href="http://bluebirdjs.com/docs/api/promise.all.html"><code>Promise.all([...])</code></a> 
you have to pick the <em>last</em> element which contains the "final product". 
From our example above it would be</p>

<div class="highlight highlight-source-js"><pre>{
    key1<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>value1<span class="pl-pds">'</span></span>,
    key2<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>value2<span class="pl-pds">'</span></span>
}</pre></div>

<p>which then is passed back to the transformation chain. Following this pattern 
you can do almost everything with the JS object, like</p>

<ul>
<li>deleting properties</li>
<li>changing properties to other types</li>
<li>validating and throwing error if not valid</li>
<li>...</li>
</ul>

<p>Whatever you do during transformation, just keep it valid ;-)</p>

<h2>
<a id="using-custom-logger" class="anchor" href="#using-custom-logger" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Custom Logger</h2>

<p>It is usual that you use an own <code>logger</code> in your application. This module supports you by 
letting you inject your logger as constructor argument: the <code>Reader</code>, <code>Transformer</code> and 
<code>Writer</code> constructor will accept an (optional) logger object.</p>

<p>If you do not provide one, then the default logger is <code>console</code>.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> logger <span class="pl-k">=</span> <span class="pl-k">...</span>;

<span class="pl-k">var</span> reader <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Reader</span>(logger);
<span class="pl-k">var</span> transformer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Transformer</span>(logger);
<span class="pl-k">var</span> writer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Writer</span>(logger);</pre></div>

<p>At least, the passed logger object <em>has to</em> support the following functions:</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">info</span>(<span class="pl-smi">msg</span>)
function debug(msg)
function error(msg)</pre></div>

<h1>
<a id="api-reference" class="anchor" href="#api-reference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Reference</h1>

<p>For more details on how to use the API, please refer to the 
<a href="https://github.com/deadratfink/jy-transform/wiki/API-v1.0">API Reference</a> 
wiki which describes the full API and provides more examples.</p>

<h1>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Changelog</h1>

<p>The complete changelog is listed in the wiki <a href="https://github.com/deadratfink/jy-transform/wiki/Changelog">Changelog</a> section.</p>

<h1>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contributing</h1>

<p>Pull requests and stars are always welcome. Anybody is invited to take part 
into this project. For bugs and feature requests, please create an 
<a href="https://github.com/deadratfink/jy-transform/issues">issue</a>.
When contributing as coder, please take care of the following conventions:</p>

<ul>
<li>Enter yourself in the <code>constributors</code> section of <em>package.json</em>.</li>
<li>We strictly follow <a href="http://semver.org">Semantic Versioning 2</a> rules.</li>
<li>The <code>development</code> branch is the leading branch and is protected. Create bugfix and feature 
branches (or fork into you own namespace) and create pull 
requests to <code>development</code> when finished. Any of these should be prefixed with 
<code>bugfix/#...</code> or <code>feature/#...</code> (followed by issue number and a short, "underscored" 
proper meaning), e.g. 

<ul>
<li><code>bugfix/#8_fix_js_reading_with_require</code></li>
<li><code>feature/#14_multidocument_support</code></li>
</ul>
</li>
<li>Remember that name could need to be enclosed in quotes, e.g. 
<code>$ git checkout -b 'feature/#19_...'</code>
when using git shell command.</li>
<li>The <code>master</code> branch is protected and is the stable branch after a release. 
It will never be pushed directly (only on release build).</li>
<li>Indention for any file is 4 SPACEs.</li>
<li>Keep code coverage high (&gt; 95%).</li>
<li>Doc everything with <a href="http://usejsdoc.org/">JSDocs</a> and document concepts in 
<a href="https://github.com/deadratfink/jy-transform/blob/development/README.md">README.md</a>
or <a href="https://github.com/deadratfink/jy-transform/wiki">Wiki</a>.</li>
<li>Use single parenthesis (<code>'...'</code>) in <em>*.js</em> files instead of double parenthesis (<code>"..."</code>).</li>
<li>Avoid the of use parenthesis for keys in JSON objects.</li>
<li>Use the strict mode (<code>'use strict';</code>) in <em>*.js</em> files.</li>
<li>File names should be lower-case with hyphens as divider, e.g. <em>options-handler.js</em>.</li>
<li>Markdown documentation files should be upper-case with <em>.md</em> as extension, placed 
in <em>./docs</em>, e.g. <em>USAGE.md</em>. The <em>README.md</em> is build up by these files concatenated 
by <code>npm run docs</code> command. Any new files have to be added to <code>scripts.docs</code> section of 
<em>package.json</em>. Don't forget to regenerate <em>README.md</em> before committing.</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/deadratfink/jy-transform">jy-transform</a> is maintained by <a href="https://github.com/deadratfink">deadratfink</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
