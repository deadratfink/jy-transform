#!/usr/bin/env node

'use strict';

var constants = require('./lib/constants.js');
var cli = require('cli');
var path = require('path');
var Transformer = require('./lib/transformer.js');
var transformer = new Transformer(cli);

///////////////////////////////////////////////////////////////////////////////
// CLI INIT
///////////////////////////////////////////////////////////////////////////////

/**
 * How to use the CLI.
 *
 * @type {string}
 * @private
 */
var usage = path.basename(__filename) + ' [OPTIONS]';

/**
 * The path to package.json.
 *
 * @type {string}
 * @private
 */
var packagePath = __dirname + '/package.json';

/**
 * The options description for parsing the command line input, must be an object with opts defined like:
 * ```
 * long_tag: [short_tag, description, value_type, default_value];
 * ```
 * @type {{origin: *[], target: *[], src: string[], dest: *[], indent: *[], force: string[], exports: string[]}}
 * @private
 */
var options = {
    origin:  [ 'o', 'The conversion origin: [ ' + constants.JS + ' | ' + constants.JSON + ' | ' + constants.YAML + ' ].', 'string', constants.DEFAULT_OPTIONS.origin ],
    target:  [ 't', 'The conversion target: [ ' + constants.JS + ' | ' + constants.JSON + ' | ' + constants.YAML + ' ].', 'string', constants.DEFAULT_OPTIONS.target ],
    src:     [ 's', 'The absolute/relative input file path.', 'path'],
    dest:    [ 'd', 'The absolute/relative output file path. When this options is ommited then the output file is stored relative to the input file (same base name but with another extension if type differs). If input and output type are the same then the file overwriting is handled depending on the \'--force\' value!', 'path', constants.DEFAULT_OPTIONS.dest],
    indent:  [ 'i', 'The indention for pretty-print: 1 - 8.', 'int', constants.DEFAULT_INDENT ],
    force:   [ 'f', 'Force overwriting of existing output files on write phase. When files are not overwritten (which is default), then the next transformation with same output file name gets a consecutive number on the base file name, e.g. in case of foo.yaml it would be foo(1).yaml.' ],
    exports: [ 'x', 'Define a \'module.exports[.identifier] = \' identifier, for usage in JS destination files only and must be a valid JS identifier!', 'string', constants.DEFAULT_OPTIONS.exports ]
};

/**
 * The main entry callback. When calling cli.main() this receives the `options`
 * given on CLI, does the transformation with these options and prints the
 * result to the CLI.
 *
 * @param args    - Not used inside this method!
 * @param options - The options set on CLI.
 * @private
 */
function main(args, options) {
    return transformer.transform(options)
        .then(function (msg) {
            cli.info(msg);
        })
        .catch(function (err) {
            cli.error('////////////////////////////////////////////////////////////////////////////////');
            cli.error(err);
            cli.debug(err.stack);
            cli.error('////////////////////////////////////////////////////////////////////////////////');
            cli.getUsage(1);
        });
}

/**
 * Init the CLI instance.
 */
cli.setUsage(usage);
cli.setApp(packagePath);
cli.enable('version', 'status', 'timeout');
cli.parse(options);
cli.main(main);
